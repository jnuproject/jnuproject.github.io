<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Dream Survivors</title>

<!-- 폰트 -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2107@1.1/DungGeunMo.woff" rel="stylesheet" as="font" type="font/woff" crossorigin>
<link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.1/DNFBitBit.woff" rel="stylesheet" as="font" type="font/woff" crossorigin>

<style>
  :root{
    --brand:#00a99c;
    --brand-d:#00877d;
    --ink:#003d38;
    --bg-a:#e6f5f2;
    --bg-b:#d4ebe7;
    --white:#ffffff;
  }

  /* 기본 스타일 */
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;padding:0;overflow:hidden;
    background:linear-gradient(135deg,var(--bg-a) 0%,var(--bg-b) 100%);
    font-family:'Press Start 2P',cursive;color:var(--ink); user-select:none;
  }
  #gameCanvas{display:block}

  /* 오버레이 */
  .overlay{
    position:absolute; inset:0; display:flex; flex-direction:column;
    justify-content:center; align-items:center; text-align:center; z-index:10;
    background:rgba(255,255,255,.85); backdrop-filter:blur(5px); color:var(--ink);
  }
  .hidden{display:none!important}

  /* 타이포그래피 */
  h1{color:var(--brand); text-shadow:3px 3px #fff; font-size:48px; margin:0 0 20px}
  h2{color:var(--brand); text-shadow:2px 2px #fff; margin:0 0 30px}
  p{line-height:1.5; font-size:14px; color:var(--ink); max-width:600px; margin:10px auto}

  /* 버튼 */
  button{
    background:var(--brand); color:#fff; border:0; border-bottom:4px solid var(--brand-d);
    padding:15px 30px; font:16px 'Press Start 2P',cursive; cursor:pointer; margin:10px;
    transition:all .2s; image-rendering:pixelated; border-radius:8px; text-shadow:1px 1px 2px rgba(0,0,0,.2);
  }
  button:hover{background:#00c2b2; transform:translateY(-2px); border-bottom-width:6px}
  button:active{transform:translateY(2px); border-bottom-width:2px}

  /* HUD 영역 */
  #hud{position:absolute; inset:0 auto auto 0; width:100%; padding:10px; pointer-events:none; z-index:5}
  .xp-container{
    width:100%; height:20px; background:rgba(255,255,255,.5); border:2px solid #fff; border-radius:10px; position:relative;
    box-shadow:0 0 10px rgba(255,255,255,.5);
  }
  #xpBar{
    height:100%; background:var(--brand); width:0%; transition:width .2s; border-radius:8px;
    box-shadow:0 0 10px var(--brand), 0 0 15px #fff;
  }
  #levelText{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    color:#00383a; font-size:12px; text-shadow:1px 1px 0 #fff;
  }
  .top-info{
    display:flex; justify-content:space-between; margin-top:10px; color:#fff; font-size:16px; text-shadow:2px 2px 4px var(--ink);
  }

  /* 레벨 업 */
  #levelUpMenu{
    background:rgba(255,255,255,.8); border:4px solid #fff; padding:20px; border-radius:15px; max-width:800px; color:var(--ink);
    box-shadow:0 10px 30px rgba(0,0,0,.1);
  }
  #upgradeContainer{
    display:flex; gap:20px; justify-content:center; flex-wrap:wrap; margin-top:20px;
  }
  .upgrade-card{
    background:#fff; border:3px solid #e6f5f2; width:200px; padding:15px; cursor:pointer;
    transition:transform .2s, box-shadow .2s, border-color .2s;
    display:flex; flex-direction:column; align-items:center; border-radius:10px; position:relative;
  }
  .upgrade-card:hover{transform:scale(1.05); border-color:var(--brand); box-shadow:0 0 20px rgba(0,169,156,.5)}
  .upgrade-icon{width:64px; height:64px; margin-bottom:10px; background:#f0faff; display:flex; justify-content:center; align-items:center; border:2px solid var(--brand); border-radius:50%}
  .upgrade-title{color:var(--brand); font-size:12px; margin-bottom:5px}
  .upgrade-type{color:#8e44ad; font-size:8px; margin-bottom:10px}
  .upgrade-desc{color:var(--ink); font-size:10px; line-height:1.4}
  .new-tag{background:#ff85a2; color:#fff; padding:2px 5px; font-size:8px; position:absolute; top:5px; right:5px; border-radius:5px}

  /* 정책 모달 */
  #policyModal{
    background:#fff; padding:30px 50px; border-radius:15px; border:4px solid var(--brand);
    width:80%; height:80%; max-width:1200px; overflow-y:auto; text-align:left;
    box-shadow:0 10px 30px rgba(0,0,0,.2);
  }
  #policyListContainer h3{color:#00877d; border-bottom:2px solid #e6f5f2; padding-bottom:10px; margin-top:25px; font-size:18px}
  #policyListContainer ul{list-style:none; padding-left:0}
  #policyListContainer li{font-size:14px; padding:12px 0; color:var(--ink); border-bottom:1px dashed #d4ebe7}
  .policy-desc{font-size:10px; color:#555; margin-top:8px; padding-left:20px; line-height:1.6}

  /* 조이스틱 */
  #joystick-base{
    position:fixed; bottom:8vh; right:8vw; width:min(20vw,120px); height:min(20vw,120px); border-radius:50%;
    background:rgba(255,255,255,.1); border:2px solid rgba(255,255,255,.3); touch-action:none; display:none; z-index:20;
  }
  #joystick-thumb{
    position:absolute; width:40%; height:40%; top:30%; left:30%; border-radius:50%;
    background:rgba(255,255,255,.5); transform:translate(0,0); transition:transform .1s ease-out;
  }

  /* 코스 포인터/터치 장치(태블릿·폰)에서도 가상 조이스틱이 보이도록 보장 */
  @media (pointer:coarse){
    #joystick-base{ display:block !important; }
  }

  /* 시작 화면(반응형) */
  #startScreen{padding:40px 20px}
  /* #startScreen .screen-logo{
    position:absolute; bottom:40px; left:50%; transform:translateX(-50%);
    max-width:200px; width:50%;
  } */
  #startScreen .start-content{text-align:center}
  #startScreen h1{font-size:clamp(28px,7vw,48px); white-space:normal; word-break:keep-all; text-align:center;}
  #startScreen p{font-size:clamp(12px,3.5vw,14px); line-height:1.6}

  .screen-logo {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    max-width: 200px;
    width: 50%;
  }

  @media (max-width:768px){
    h1{font-size:8vw}
    p{font-size:clamp(12px,3.5vw,14px); line-height:1.6}
    #victoryScreen h1,#gameOverScreen h1{font-size:clamp(28px,8vw,48px)}
  }
</style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <!-- 모바일 조이스틱 -->
  <div id="joystick-base"><div id="joystick-thumb"></div></div>

  <!-- HUD 영역 -->
  <div id="hud">
    <div class="xp-container">
      <div id="xpBar"></div>
      <div id="levelText">LV 1</div>
    </div>
    <div class="top-info">
      <div id="timer">00:00</div>
      <div id="killCount">✨ 0</div>
    </div>
  </div>

  <!-- 시작 -->
  <div id="startScreen" class="overlay">
    <div class="start-content">
      <h1>DREAM SURVIVORS</h1>
      <p>드림과 함께 꿈 속의 악몽들을 헤쳐나가세요!</p>
      <p>이동: PC는 방향키 / 모바일은 조이스틱 / 공격은 자동입니다.</p>
      <p style="font-size:10px; color:#003d38; opacity:0.5; margin-top:8px;">
        ※ 본 게임은 <em>Vampire Survivors</em>를 레퍼런스로 제작되었습니다.
      </p>
      <button id="btnStart">꿈 속으로</button>
    </div>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 일시정지 -->
  <div id="pauseMenu" class="overlay hidden">
    <h2>잠깐의 휴식</h2>
    <div id="statsContainer" style="text-align:left;margin-bottom:20px;font-size:10px"></div>
    <button id="btnResume">계속하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 게임 오버 -->
  <div id="gameOverScreen" class="overlay hidden">
    <h1 id="goTitle" style="color:#b30000">꿈속에 갇혔습니다...</h1>
    <h2 id="goTime">버틴 시간: 00:00</h2>
    <p id="goKills">물리친 악몽: 0</p>
    <p id="goLevel">성장 레벨: 1</p>
    <button id="btnRestart">다시 도전하기</button>
    <button id="btnPolicyGO">정책 확인하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 승리 -->
  <div id="victoryScreen" class="overlay hidden">
    <h1 style="color:var(--brand)">꿈속에서 깨어났습니다!</h1>
    <p>우리의 꿈이 현실이 되었습니다.</p>
    <p id="vKills">물리친 악몽: 0</p>
    <p style="font-size:12px;">“함께 꿈꾸는 캠퍼스, 드림이 만듭니다.”</p>
    <button id="btnRestartVic">다시하기</button>
    <button id="btnPolicyVic">정책 확인하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 레벨 업 -->
  <div id="levelUpScreen" class="overlay hidden">
    <div id="levelUpMenu">
      <h2 style="color:#8e44ad;margin:0">성장!</h2>
      <p style="margin-bottom:0">새로운 꿈의 조각을 선택하세요</p>
      <div id="upgradeContainer"></div>
    </div>
  </div>

  <!-- 정책 -->
  <div id="policyScreen" class="overlay hidden" style="z-index:11">
    <div id="policyModal">
      <h2 style="text-align:center">드림의 정책</h2>
      <div id="policyListContainer"></div>
      <button id="btnClosePolicy" style="display:block;margin:20px auto 0">닫기</button>
    </div>
  </div>

<script>
/* =========================================================
   드림 서바이버즈 — 엔진과 게임 로직 (리팩터링)
   - 기능/연출 동일, 구조/가독성 개선
========================================================= */

/* ---------- 설정 및 전역 ---------- */
const C = {
  WIDTH: innerWidth,
  HEIGHT: innerHeight,
  FPS: 60,
  TILE_SIZE: 128,
  COLORS: {
    bg:'#e6f5f2', grid:'#fff7e0', player:'#00a99c', hp:'#00a99c', hpBg:'#98d2c6',
    e1:'#ffc1e3', e2:'#ffb3ba', e3:'#ffffba', e4:'#d1b3ff', e5:'#008080',
    xp1:'#ffd700', xp2:'#ffec8b', xp3:'#ffffff', dmgWhite:'#ffffff', dmgCrit:'#ff85a2'
  }
};

/* ✅ 최적화: 중앙 게임 상태에 런타임 캐시 추가 */
const GS = {
  canvas: document.getElementById('gameCanvas'),
  ctx: document.getElementById('gameCanvas').getContext('2d',{alpha:false}),
  state:'start',
  player:null,
  enemies:[], projectiles:[], enemyProjectiles:[],
  gems:[], potions:[], particles:[], particlePool:[], damageTexts:[],
  camera:{x:0,y:0}, input:{up:false,down:false,left:false,right:false},
  audio:null, time:0, kills:0, frameCount:0, lastTime:0, dt:0,
  screenShake:0, spawnTimer:0, bossAlert:{text:'',life:0},
  victoryInProgress:false, stageIndex:0, stageTitle:null,
  bossHasSpawned:false, level5BossTriggered:false, level10BossTriggered:false,
  level15BossTriggered:false, level20BossTriggered:false,
  currentEnemyNames:null, currentBg:null, startTime:null, gameOver:false,
  _stageTransitioning:false,
  gradientCache:null
};

/* ✅ 최적화: 기기 프로필이 예산을 조정하면서 비주얼 유지 */
const DEVICE = (() => {
  const nav = navigator || {};
  const coarse = (matchMedia && matchMedia('(pointer:coarse)').matches) ||
                 'ontouchstart' in window ||
                 (nav.maxTouchPoints || 0) > 0 ||
                 innerWidth <= 820;
  // ✅ 기본 픽셀 밀도와 비주얼 품질 유지, 로직 부하만 줄이기
  return {
    isMobile: coarse,
    pixelRatio: Math.min(window.devicePixelRatio || 1, 2), // 모바일에서는 최대 2로 제한
    enemyCap: coarse ? 80 : 280,
    particleCap: coarse ? 100 : 360,
    cullX: coarse ? 500 : 900,
    cullY: coarse ? 400 : 600
  };
})();

// ✅ 적응형 성능 스케일링 시스템
const PERF = {};
PERF.score = (() => {
  let score = 1;
  if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 6) score *= 0.8;
  if (navigator.deviceMemory && navigator.deviceMemory < 4) score *= 0.7;
  if (/Mali|Adreno|PowerVR/i.test(navigator.userAgent)) score *= 0.8;
  return Math.max(score, 0.5);
})();

const HUD = {
  xpBar: document.getElementById('xpBar'),
  levelText: document.getElementById('levelText'),
  timer: document.getElementById('timer'),
  killCount: document.getElementById('killCount')
};

/* ---------- 리사이즈 ---------- */
function resize() {
  // 고성능 모니터(특히 고 DPI)에서 성능 유지를 위해 devicePixelRatio 제한
  const ratio = DEVICE.pixelRatio;
  C.WIDTH = Math.floor(innerWidth);
  C.HEIGHT = Math.floor(innerHeight);
  GS.canvas.width = Math.floor(C.WIDTH * ratio);
  GS.canvas.height = Math.floor(C.HEIGHT * ratio);
  GS.canvas.style.width = `${C.WIDTH}px`;
  GS.canvas.style.height = `${C.HEIGHT}px`;
  GS.ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  GS.ctx.imageSmoothingEnabled = false;
  GS.ctx.mozImageSmoothingEnabled = false;
  GS.ctx.webkitImageSmoothingEnabled = false;
  GS.gradientCache=null;
  // ✅ GPU 합성과 하드웨어 가속 힌트 사용
  // 모바일은 medium, 데스크톱은 high로 스무딩 설정
  GS.ctx.imageSmoothingEnabled = true;
  if (DEVICE.isMobile) {
    GS.ctx.imageSmoothingQuality = "medium";
  } else {
    GS.ctx.imageSmoothingQuality = "high";
  }
  GS.canvas.style.willChange = "transform, opacity";
  GS.canvas.style.transform = "translateZ(0)";
  GS.canvas.style.imageRendering = "auto";
  // ✅ 모바일 합성을 부드럽게 하는 GPU CSS 힌트 추가
  GS.canvas.style.backfaceVisibility = "hidden";
  GS.canvas.style.contain = "layout style paint";
  // CPU 배칭: 정적 배경 버퍼 생성/재생성
  GS.bgBuffer = null;
}
let resizeTimer;
addEventListener('resize', ()=> {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 200);
});
resize();

/* ---------- 수학 유틸 ---------- */
const M = {
  dist:(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1),
  distSq:(x1,y1,x2,y2)=> (x2-x1)**2 + (y2-y1)**2,
  angle:(x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1),
  rand:(min,max)=>Math.random()*(max-min)+min,
  randInt:(min,max)=>Math.floor(Math.random()*(max-min+1))+min,
  clamp:(v,min,max)=>Math.min(Math.max(v,min),max),
  lerp:(a,b,t)=>a+(b-a)*t,
  collides:(a,b)=> M.distSq(a.x,a.y,b.x,b.y) < (a.r+b.r)**2,
  formatTime:(s)=> {
    const m = Math.floor(s/60), sec = Math.floor(s%60);
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
};

/* ---------- 오디오 ---------- */
class AudioSys{
  constructor(){ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); this.masterVol=.3; }
  playTone(freq,type,dur,vol=1,slide=0){
    if(GS.state==='paused') return;
    const {ctx} = this; const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type=type; osc.frequency.setValueAtTime(freq, ctx.currentTime);
    if(slide!==0) osc.frequency.exponentialRampToValueAtTime(freq+slide, ctx.currentTime+dur);
    g.gain.setValueAtTime(vol*this.masterVol, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime+dur);
    osc.connect(g); g.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+dur);
  }
  sfxShoot(){this.playTone(M.rand(600,800),'sine',.1,.2,200)}
  sfxEnemyShoot(){this.playTone(M.rand(300,400),'square',.1,.1)}
  sfxHit(){this.playTone(M.rand(200,300),'triangle',.1,.3)}
  sfxXp(){this.playTone(M.rand(1000,1200),'sine',.08,.15)}
  sfxLevelUp(){
    const now = this.ctx.currentTime;
    [523,659,783,1046].forEach((f,i)=>{
      const o=this.ctx.createOscillator(), g=this.ctx.createGain();
      o.type='triangle'; o.frequency.value=f;
      g.gain.setValueAtTime(.2, now+i*.1);
      g.gain.linearRampToValueAtTime(0, now+i*.1+.2);
      o.connect(g); g.connect(this.ctx.destination);
      o.start(now+i*.1); o.stop(now+i*.1+.2);
    });
  }
  sfxHurt(){this.playTone(150,'sawtooth',.3,.5,-50)}
  sfxDie(){this.playTone(100,'sawtooth',1.5,.6,-80)}
}

/* ---------- 그리기 헬퍼 ---------- */
const Draw = {
  glow:(color='rgba(0,0,0,0.6)', blur=20, alpha=0.8)=>{
    if (GS.lowPerfMode || DEVICE.isMobile) return;
    const ctx=GS.ctx;
    ctx.save();
    ctx.shadowBlur = blur;
    ctx.shadowColor=color;
    ctx.globalAlpha=alpha;
  },
  resetGlow:()=>{ const ctx=GS.ctx; ctx.restore(); },
  circle(x,y,r,fill,stroke=null,lw=2){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    if (cx<-r||cx>C.WIDTH+r||cy<-r||cy>C.HEIGHT+r) return;
    const ctx=GS.ctx; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fillStyle=fill; ctx.fill();
    if(stroke){ctx.strokeStyle=stroke; ctx.lineWidth=lw; ctx.stroke();}
  },
  rect(x,y,w,h,color,angle=0){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    const ctx=GS.ctx; ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
    ctx.fillStyle=color; ctx.fillRect(-w/2,-h/2,w,h); ctx.restore();
  },
  text(str,x,y,size,color,align='center'){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    const ctx=GS.ctx; ctx.font = `${size}px 'Press Start 2P'`;
    ctx.fillStyle=color; ctx.textAlign=align; ctx.fillText(str,cx,cy);
  },
  background(){
    if(!GS.gradientCache){
      const [c1,c2]=GS.currentBg||['#e6f5f2','#d4ebe7'];
      const g=GS.ctx.createLinearGradient(0,0,C.WIDTH,C.HEIGHT);
      g.addColorStop(0,c1); g.addColorStop(1,c2);
      GS.gradientCache=g;
    }
    GS.ctx.fillStyle=GS.gradientCache;
    GS.ctx.fillRect(0,0,C.WIDTH,C.HEIGHT);
  }
};

/* ---------- 기본 엔티티 ---------- */
class Entity{ constructor(x,y,r){ this.x=x; this.y=y; this.r=r; this.active=true; } }

/* ---------- 이펙트 ---------- */
class Particle extends Entity{
  constructor(x,y,color,size,speed,life){ super(x,y,0); this.reset(x,y,color,size,speed,life); }
  reset(x,y,color,size,speed,life){
    this.x=x; this.y=y; this.color=color; this.size=size; this.life=life; this.maxLife=life;
    const a=M.rand(0,Math.PI*2); this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed; this.active=true; return this;
  }
  update(){ this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.life-=GS.dt; if(this.life<=0){this.active=false; GS.particlePool.push(this);} }
  draw(){ const a=this.life/this.maxLife; GS.ctx.globalAlpha=a; Draw.circle(this.x,this.y,this.size,this.color); GS.ctx.globalAlpha=1; }
}
class DamageText extends Entity{
  constructor(x,y,dmg,isCrit){ super(x+M.rand(-10,10),y-20,0); this.text=Math.round(dmg); this.color=isCrit?C.COLORS.dmgCrit:C.COLORS.dmgWhite; this.size=isCrit?20:12; this.life=1; this.vy=-50; }
  update(){ this.y+=this.vy*GS.dt; this.life-=GS.dt; if(this.life<=0)this.active=false; }
  draw(){ GS.ctx.globalAlpha=Math.min(1,this.life*2); Draw.text(this.text,this.x,this.y,this.size,this.color); GS.ctx.globalAlpha=1; }
}
/* ✅ 최적화: 기기별 파티클 제한을 준수하는 풀 */
function spawnParticles(x,y,color,count,hw=false){
  const pool=GS.particlePool;
  const limit=Math.min(count, DEVICE.particleCap);
  for(let i=0;i<limit;i++){
    // ✅ 저사양 기기에서는 파티클 생성을 간헐적으로 생략
    if (Math.random() > PERF.score) return;
    const speed = hw? M.rand(50,150): M.rand(100,300);
    const size = hw? M.rand(2,5): M.rand(1,3);
    const life = M.rand(.2,.5);
    const particle = pool.length>0 ? pool.pop().reset(x,y,color,size,speed,life) : new Particle(x,y,color,size,speed,life);
    GS.particles.push(particle);
  }
}
/* ✅ 최적화: 업데이트 중 비활성 객체를 제자리 압축으로 제거 */
function stepEntities(list){
  let write=0;
  for(let i=0;i<list.length;i++){
    const item=list[i];
    item.update();
    if(item.active) list[write++]=item;
  }
  list.length=write;
}

/* ---------- 수집 아이템 ---------- */
class ExperienceOrb extends Entity{
  constructor(x,y,value){
    super(x,y,6); this.value=value;
    if(value<5){ this.color=C.COLORS.xp1; this.r=5; }
    else if(value<20){ this.color=C.COLORS.xp2; this.r=7; }
    else{ this.color=C.COLORS.xp3; this.r=9; }
    this.vx=0; this.vy=0; this.magnetized=false;
  }
  update(){
    const d2 = M.distSq(this.x,this.y,GS.player.x,GS.player.y);
    if(this.magnetized||d2<GS.player.stats.magnet**2){
      this.magnetized=true;
      const a = M.angle(this.x,this.y,GS.player.x,GS.player.y);
      const speed=600; this.vx=M.lerp(this.vx,Math.cos(a)*speed,5*GS.dt);
      this.vy=M.lerp(this.vy,Math.sin(a)*speed,5*GS.dt);
      this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt;
      if(d2<(GS.player.r+this.r)**2){ GS.player.gainXp(this.value); this.active=false; if(GS.audio) GS.audio.sfxXp(); }
    }else{ this.y+=Math.sin(GS.time*5+this.x)*10*GS.dt; }
  }
  draw(){
    const cx = this.x-GS.camera.x + C.WIDTH/2;
    const cy = this.y-GS.camera.y + C.HEIGHT/2;
    if (cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const ctx=GS.ctx; ctx.save(); ctx.translate(cx,cy); ctx.rotate(GS.time);
    ctx.beginPath(); ctx.moveTo(0,-this.r);
    for(let i=0;i<5;i++){ ctx.rotate(Math.PI/5); ctx.lineTo(0,-(this.r*.5)); ctx.rotate(Math.PI/5); ctx.lineTo(0,-this.r); }
    ctx.closePath(); ctx.fillStyle=this.color; ctx.fill(); ctx.restore();
  }
}
class HealthPotion extends Entity{
  constructor(x,y){ super(x,y,10); this.color='#ff6b6b'; this.healAmount = GS.player.stats.maxHp*0.20; }
  update(){
    if(M.collides(this,GS.player)){
      GS.player.hp = Math.min(GS.player.stats.maxHp, GS.player.hp + this.healAmount);
      this.active=false; if(GS.audio) GS.audio.playTone(800,'sine',.2,.4);
    }
  }
  draw(){
    const cx = this.x-GS.camera.x + C.WIDTH/2;
    const cy = this.y-GS.camera.y + C.HEIGHT/2;
    if (cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const r=this.r, ctx=GS.ctx; ctx.fillStyle=this.color; ctx.beginPath();
    ctx.moveTo(cx, cy + r/4);
    ctx.quadraticCurveTo(cx, cy, cx - r/4, cy);
    ctx.quadraticCurveTo(cx - r/2, cy, cx - r/2, cy + r/4);
    ctx.quadraticCurveTo(cx - r/2, cy + r/2, cx, cy + r);
    ctx.quadraticCurveTo(cx + r/2, cy + r/2, cx + r/2, cy + r/4);
    ctx.quadraticCurveTo(cx + r/2, cy, cx + r/4, cy);
    ctx.quadraticCurveTo(cx, cy, cx, cy + r/4);
    ctx.fill();
  }
}

/* ---------- 발사체 ---------- */
class Projectile extends Entity{
  constructor(x,y,r,vx,vy,damage,pierce,duration,color,kb){
    super(x,y,r);
    Object.assign(this,{vx,vy,damage,pierce,duration,color,kb});
    this.hitList=[];
  }
  update(){ 
    this.x+=this.vx*GS.dt; 
    this.y+=this.vy*GS.dt; 
    this.duration-=GS.dt; 
    if(this.duration<=0) this.active=false; 
    this.hitList=[];
  }
  draw(){
    const cx=this.x-GS.camera.x+C.WIDTH/2;
    const cy=this.y-GS.camera.y+C.HEIGHT/2;
    if(cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const ctx=GS.ctx;

    // 무기 종류에 따라 다른 모양으로 그림
    if(this.color==='#87CEFA'){
      // 마법봉 : 별 모양 탄환
      Draw.glow(this.color,14,0.95);
      const spikes=5, outer=this.r, inner=this.r*0.45;
      ctx.beginPath();
      for(let i=0;i<spikes;i++){
        const a=(i*Math.PI*2/spikes)+(GS.time*6);
        const ax=cx+Math.cos(a)*outer;
        const ay=cy+Math.sin(a)*outer;
        ctx.lineTo(ax,ay);
        const b=a+Math.PI/spikes;
        const bx=cx+Math.cos(b)*inner;
        const by=cy+Math.sin(b)*inner;
        ctx.lineTo(bx,by);
      }
      ctx.closePath();
      ctx.fillStyle=this.color;
      ctx.fill();
      Draw.resetGlow();
      ctx.beginPath(); ctx.arc(cx,cy,Math.max(1,this.r*0.35),0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    } else if(this.color==='#44ffaa'){
      // 부메랑류 : 타원형 회전 탄환
      Draw.glow(this.color,18,0.9);
      ctx.beginPath();
      ctx.ellipse(cx,cy,this.r*1.6,this.r*0.9,Math.atan2(this.vy,this.vx),0,Math.PI*2);
      ctx.fillStyle=this.color; ctx.fill();
      Draw.resetGlow();
    } else {
      // 기본 : 긴 타원형 파편 형태
      Draw.glow(this.color,12,0.9);
      const angle=Math.atan2(this.vy,this.vx);
      const w=Math.max(1,this.r*1.6);
      const h=Math.max(1,this.r);
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-w/2+h/2,-h/2);
      ctx.arcTo(w/2-h/2,-h/2,w/2-h/2,h/2,h/2);
      ctx.arcTo(w/2-h/2,h/2,-w/2+h/2,h/2,h/2);
      ctx.closePath();
      ctx.fillStyle=this.color;
      ctx.fill();
      ctx.beginPath(); ctx.globalAlpha=0.8;
      ctx.arc(0,0,Math.max(0.5,this.r*0.45),0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fill();
      ctx.globalAlpha=1.0;
      ctx.restore();
      Draw.resetGlow();
    }
  }
  onHit(enemy){
    const isCrit=Math.random()<GS.player.stats.critChance;
    const dmg=this.damage*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
    enemy.takeDamage(dmg,isCrit,this.kb,Math.atan2(this.vy,this.vx));
    this.pierce--; if(this.pierce<0) this.active=false;
    if(GS.audio) GS.audio.sfxHit();
  }
}
class EnemyProjectile extends Entity{
  constructor(x,y,r,vx,vy,damage,duration,color){ super(x,y,r); Object.assign(this,{vx,vy,damage,duration,color}); }
  update(){
    this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.duration-=GS.dt;
    if(this.duration<=0) this.active=false;
    if(M.collides(this,GS.player)){ GS.player.takeDamage(this.damage); this.active=false; }
  }
  draw(){ Draw.glow(this.color,15); Draw.circle(this.x,this.y,this.r,this.color,'#000',2); Draw.resetGlow(); }
}
class BoomerangProj extends Projectile{
  constructor(p){ super(p.x,p.y,p.r,p.vx,p.vy,p.dmg,999,p.dur,'#44ffaa',p.kb); this.speed=Math.hypot(this.vx,this.vy); this.angle=Math.atan2(this.vy,this.vx); this.timer=0; this.returnTime=p.dur/2; }
  update(){
    this.timer+=GS.dt; const currentSpeed = this.speed*(1-(this.timer/this.returnTime));
    this.x+=Math.cos(this.angle)*currentSpeed*GS.dt; this.y+=Math.sin(this.angle)*currentSpeed*GS.dt;
    this.duration-=GS.dt;
    if(this.duration<=0 || (this.timer>this.returnTime && M.distSq(this.x,this.y,GS.player.x,GS.player.y)<1600)) this.active=false;
    this.hitList=[];
  }
  draw(){
    Draw.glow(this.color,18,0.9);
    Draw.rect(this.x,this.y,this.r*2.5,this.r,this.color,this.timer*15);
    Draw.resetGlow();
  }
}

/* ---------- 무기 ---------- */
class Weapon{
  constructor(name,iconColor){
    Object.assign(this,{name,iconColor});
    this.level=0; this.maxLevel=8; this.cooldown=0;
    this.baseDmg=10; this.baseCd=1.5; this.baseSpd=400; this.baseDur=2; this.baseArea=1; this.baseAmount=1; this.basePierce=0; this.kb=100;
  }
  get stats(){
    const ps=GS.player.stats;
    return {
      dmg:this.baseDmg*(1+this.level*.2),
      cd:this.baseCd*(1-this.level*.05)*ps.cooldown,
      spd:this.baseSpd*(1+this.level*.1)*ps.speedProj,
      dur:this.baseDur*(1+this.level*.1)*ps.duration,
      area:this.baseArea*(1+this.level*.15)*ps.area,
      amount:this.baseAmount+Math.floor(this.level/2)+ps.amount,
      pierce:this.basePierce+Math.floor(this.level/3),
      kb:this.kb
    };
  }
  update(){ this.cooldown-=GS.dt; if(this.cooldown<=0){ this.attack(); this.cooldown=this.stats.cd; } }
  getNearestEnemy(){
    let nearest=null, min=Infinity;
    for(const e of GS.enemies){ const d=M.distSq(GS.player.x,GS.player.y,e.x,e.y); if(d<C.WIDTH**2 && d<min){ min=d; nearest=e; } }
    return nearest;
  }
  attack(){} getDescription(){ return "Increases stats." }
}
class Wand extends Weapon{
  constructor(){ super("의견 전달","#66ccff"); this.baseDmg=10; this.baseCd=1.0; this.baseSpd=500; this.kb=150; this.cooldownTimer = 0; }
  attack(){
    const target=this.getNearestEnemy(); if(!target){ this.cooldown=.1; return; }
    const s=this.stats; if(GS.audio) GS.audio.sfxShoot();
    // 내부 타이머로 누적 호출 방지
    if(!this.cooldownTimer) this.cooldownTimer = 0;
    this.cooldownTimer = 0;
    this._wandAttackIndex = 0;
    this._wandAttackAmount = s.amount;
    this._wandAttackTarget = target;
  }
  update(){
    this.cooldown-=GS.dt;
    if(this.cooldown<=0){
      this.attack();
      this.cooldown=this.stats.cd;
    }
    // 내부 타이머로 발사체 순차 발사
    if(this._wandAttackAmount > 0){
      if(!this._wandAttackDelay) this._wandAttackDelay = 0;
      this._wandAttackDelay -= GS.dt*1000;
      if(this._wandAttackDelay <= 0){
        // 한 번 발사
        if(GS.state!=='running'){ this._wandAttackAmount = 0; return; }
        const t=this.getNearestEnemy() || this._wandAttackTarget;
        const s=this.stats;
        const a=M.angle(GS.player.x,GS.player.y,t.x,t.y) + M.rand(-.1,.1);
        GS.projectiles.push(new Projectile(GS.player.x,GS.player.y,8*s.area,Math.cos(a)*s.spd,Math.sin(a)*s.spd,s.dmg,s.pierce,s.dur,'#87CEFA',s.kb));
        this._wandAttackAmount--;
        this._wandAttackDelay = 100;
      }
    }
  }
  getDescription(){ return "가장 가까운 적에게 마법 발사체를 발사합니다."; }
}
class OrbitingBlade extends Weapon{
  constructor(){ super("연대의 고리","#ffcc00"); this.baseDmg=15; this.baseCd=3.0; this.baseDur=2.5; this.baseArea=1; this.kb=200; this.activeBlades=[]; this.rotOffset=0; }
  update(){
    super.update(); this.rotOffset+=GS.dt*3; const s=this.stats; const radius=120*s.area;
    this.activeBlades=this.activeBlades.filter(b=>b.life>0);
    this.activeBlades.forEach((b,i)=>{
      b.life-=GS.dt;
      const ang=this.rotOffset + (Math.PI*2/this.activeBlades.length)*i;
      b.x=GS.player.x+Math.cos(ang)*radius; b.y=GS.player.y+Math.sin(ang)*radius; b.hitTimer-=GS.dt;
      if(b.hitTimer<=0){
        for(const e of GS.enemies){
          if(M.collides(b,e)){
            const isCrit=Math.random()<GS.player.stats.critChance;
            const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
            e.takeDamage(dmg,isCrit,s.kb,ang);
            if(GS.audio) GS.audio.sfxHit();
          }
        }
        b.hitTimer=.2;
      }
    });
  }
  attack(){ const s=this.stats; this.activeBlades=[]; for(let i=0;i<s.amount;i++) this.activeBlades.push({x:0,y:0,r:15*s.area,life:s.dur,hitTimer:0}); if(GS.audio) GS.audio.playTone(600,'sine',.5,.1); }
  draw(){
    this.activeBlades.forEach(b=>{
      const cx=b.x-GS.camera.x+C.WIDTH/2, cy=b.y-GS.camera.y+C.HEIGHT/2, r=b.r, ctx=GS.ctx;
      ctx.save(); ctx.translate(cx,cy); ctx.rotate(this.rotOffset*2);
      ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,Math.PI/2,false);
      ctx.quadraticCurveTo(r*.5,0,0,-r); ctx.closePath();
      Draw.glow('#ffcc00',20); ctx.fillStyle='#ffcc00'; ctx.fill(); Draw.resetGlow(); ctx.restore();
    });
  }
  getDescription(){ return "플레이어 주위를 회전하며 닿는 모든 적에게 피해를 주는 고리를 소환합니다."; }
}
class Axe extends Weapon{
  constructor(){ super("결단의 망치","#cc4444"); this.baseDmg=40; this.baseCd=2.0; this.baseSpd=500; this.basePierce=99; this.baseArea=1.5; this.kb=400; }
  attack(){
    const s=this.stats; if(GS.audio) GS.audio.playTone(200,'square',.2,.2,-50);
    for(let i=0;i<s.amount;i++){
      const spread=(s.amount>1)? M.lerp(-.5,.5, i/(s.amount-1)): 0;
      const p=new Projectile(GS.player.x,GS.player.y-20,15*s.area,Math.sin(spread)*200,-s.spd,s.dmg,s.pierce,3,'#ff85a2',s.kb);
      p.t=0; p.ro=M.rand(0,Math.PI*2);
      p.update=function(){ this.t+=GS.dt; this.vy+=800*GS.dt; this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.ro+=GS.dt*10; this.duration-=GS.dt; if(this.y>GS.player.y+C.HEIGHT/2) this.active=false; this.hitList=[]; };
      p.draw=function(){
  const ctx=GS.ctx;
  const cx=this.x-GS.camera.x+C.WIDTH/2;
  const cy=this.y-GS.camera.y+C.HEIGHT/2;
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(this.ro);
  Draw.glow(this.color,18);

  // 망치머리
  ctx.fillStyle=this.color;
  ctx.fillRect(-this.r*0.8,-this.r*0.3,this.r*1.2,this.r*0.6);

  // 손잡이
  ctx.fillStyle='#8b5a2b';
  ctx.fillRect(-this.r*0.1,-this.r*1.5,this.r*0.2,this.r*1.8);

  Draw.resetGlow();
  ctx.restore();
};
      GS.projectiles.push(p);
    }
  }
  getDescription(){ return "위쪽으로 포물선을 그리며 날아가 다수의 적을 관통하는 도끼를 던집니다."; }
}
class Beam extends Weapon{
  constructor(){ super("비전의 빛","#ff66ff"); this.baseDmg=8; this.baseCd=4.0; this.baseDur=1.5; this.kb=10; this.firing=false; this.fireTimer=0; this.targetAngle=0; }
  update(){
    super.update();
    if(this.firing){
      this.fireTimer-=GS.dt;
      if(this.fireTimer%0.2<GS.dt){
        const s=this.stats;
        const isCrit=Math.random()<GS.player.stats.critChance;
        const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
        const ex=GS.player.x+Math.cos(this.targetAngle)*C.WIDTH;
        const ey=GS.player.y+Math.sin(this.targetAngle)*C.WIDTH;
        for(const e of GS.enemies){
          const dx=ex-GS.player.x, dy=ey-GS.player.y, lenSq=dx*dx+dy*dy;
          const t=((e.x-GS.player.x)*dx + (e.y-GS.player.y)*dy)/lenSq;
          if(t<0||t>1) continue;
          const cx=GS.player.x+t*dx, cy=GS.player.y+t*dy;
          const d=M.dist(e.x,e.y,cx,cy);
          if(d<e.r + (20*s.area)) e.takeDamage(dmg,isCrit,s.kb,this.targetAngle);
        }
        if(GS.audio) GS.audio.playTone(100,'sawtooth',.1,.05);
      }
      if(this.fireTimer<=0) this.firing=false;
    }
  }
  attack(){
    const t=this.getNearestEnemy(); this.targetAngle = t? M.angle(GS.player.x,GS.player.y,t.x,t.y) : M.rand(0,Math.PI*2);
    this.firing=true; this.fireTimer=this.stats.dur; if(GS.audio) GS.audio.playTone(800,'sawtooth',.5,.1,-400);
  }
  draw(){
    if(this.firing){
      const ctx=GS.ctx, w=C.WIDTH*1.5, h=30*this.stats.area*(.5+Math.random()*.5);
      ctx.save(); ctx.translate(C.WIDTH/2,C.HEIGHT/2); ctx.rotate(this.targetAngle);
      Draw.glow('#ff66ff',30); ctx.fillStyle='rgba(255,100,255,.5)'; ctx.fillRect(0,-h/2,w,h);
      ctx.fillStyle='#fff'; ctx.fillRect(0,-h/4,w,h/2); Draw.resetGlow(); ctx.restore();
    }
  }
  getDescription(){ return "가장 가까운 적 방향으로 모든 것을 관통하는 강력한 빔을 발사합니다."; }
}
class Boomerang extends Weapon{
  constructor(){ super("드림 배지","#44ffaa"); this.baseDmg=25; this.baseCd=2.5; this.baseSpd=700; this.baseDur=2.0; this.baseArea=1.2; this.kb=250; }
  attack(){
    const t=this.getNearestEnemy(); let a = t? M.angle(GS.player.x,GS.player.y,t.x,t.y) : M.rand(0,Math.PI*2);
    const s=this.stats; if(GS.audio) GS.audio.sfxShoot();
    for(let i=0;i<s.amount;i++){
      const ang = a + M.lerp(-.3,.3, i/(s.amount||1));
      GS.projectiles.push(new BoomerangProj({x:GS.player.x,y:GS.player.y,r:12*s.area,vx:Math.cos(ang)*s.spd,vy:Math.sin(ang)*s.spd,dmg:s.dmg,dur:s.dur,kb:s.kb}));
    }
  }
  getDescription(){ return "적을 꿰뚫고 플레이어에게 다시 돌아오는 부메랑을 던집니다."; }
}
class Aura extends Weapon{
  constructor(){ super("드림 오라","#ffffff"); this.baseDmg=5; this.baseCd=.5; this.baseArea=1.0; this.kb=50; this.pulse=0; }
  attack(){
    this.pulse=1; const s=this.stats, r=80*s.area;
    const isCrit=Math.random()<GS.player.stats.critChance;
    const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
    for(const e of GS.enemies){
      if(M.distSq(GS.player.x,GS.player.y,e.x,e.y)<(r+e.r)**2){
        if((e.auraTimer||0)<=0){ e.takeDamage(dmg,isCrit,s.kb, M.angle(GS.player.x,GS.player.y,e.x,e.y)); e.auraTimer=s.cd; }
      }
    }
  }
  draw(){
    if(this.level>0){
      const r=80*this.stats.area; this.pulse=Math.max(0,this.pulse-GS.dt*2);
      const ctx=GS.ctx, cx=C.WIDTH/2, cy=C.HEIGHT/2, g=ctx.createRadialGradient(cx,cy,r*.2,cx,cy,r);
      ctx.globalAlpha=.2+this.pulse*.4; g.addColorStop(0,'rgba(0,169,156,.5)'); g.addColorStop(1,'rgba(0,169,156,0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    }
  }
  getDescription(){ return "주변의 적에게 지속적으로 피해를 주는 오라를 생성합니다."; }
}

const WEAPON_POOL = [Wand, OrbitingBlade, Axe, Beam, Boomerang, Aura];
const PASSIVE_POOL = [
  { id:'might',  name:'학생 열정', desc:'모든 공격의 피해량이 10% 증가합니다.', apply:s=>s.might+=.1,     icon:'#f00' },
  { id:'speed',  name:'발로 뛰기', desc:'캐릭터의 이동 속도가 10% 증가합니다.', apply:s=>s.moveSpeed+=20,   icon:'#fff' },
  { id:'area',   name:'홍보물 제작력', desc:'무기 공격의 범위가 10% 증가합니다.', apply:s=>s.area+=.1,      icon:'#ff0' },
  { id:'cd',     name:'기획력 향상', desc:'모든 무기의 재사용 대기시간이 8% 감소합니다.', apply:s=>s.cooldown*=.92, icon:'#00f' },
  { id:'amount', name:'팀 시너지', desc:'추가 발사체를 1개 발사합니다.', apply:s=>s.amount+=1,           icon:'#0ff' },
  { id:'magnet', name:'소통력', desc:'경험치 구슬을 획득하는 범위가 30% 증가합니다.', apply:s=>s.magnet*=1.3, icon:'#a0a' },
  { id:'health', name:'드림의 결속', desc:'최대 체력이 20% 증가하고, 현재 체력을 일부 회복합니다.', apply:s=>{s.maxHp*=1.2; GS.player.hp+=GS.player.stats.maxHp*.2;}, icon:'#b33' },
  { id:'regen',  name:'휴식의 시간', desc:'초당 0.5의 체력을 회복합니다.', apply:s=>s.regen+=.5,          icon:'#f88' }
];

/* ---------- 플레이어 ---------- */
class Player extends Entity{
  constructor(){
    super(0,0,15);
    this.baseStats={maxHp:100, moveSpeed:200, magnet:100, might:1, area:1, speedProj:1, duration:1, amount:0, cooldown:1, luck:1, critChance:.05, critDmg:2.0, armor:3, regen:0};
    this.stats={...this.baseStats};
    this.hp=this.stats.maxHp; this.xp=0; this.level=1; this.nextLevelXp=5;
    this.weapons=[]; this.passives={}; this.invulnTimer=0; this.regenTimer=0; this.facing=1;
    this.addWeapon(new Wand());
  }
  update(){
    if(GS.victoryInProgress) return;
    let dx=0, dy=0;
    if(GS.input.up)dy-=1; if(GS.input.down)dy+=1; if(GS.input.left)dx-=1; if(GS.input.right)dx+=1;
    if(dx&&dy){ const k=.7071; dx*=k; dy*=k; }
    this.x+=dx*this.stats.moveSpeed*GS.dt; this.y+=dy*this.stats.moveSpeed*GS.dt; if(dx!==0) this.facing=Math.sign(dx);
    GS.camera.x = M.lerp(GS.camera.x,this.x,10*GS.dt); GS.camera.y = M.lerp(GS.camera.y,this.y,10*GS.dt);
    this.weapons.forEach(w=>w.update());
    if(this.hp<this.stats.maxHp && this.stats.regen>0){
      this.regenTimer+=GS.dt; if(this.regenTimer>=1){ this.hp=Math.min(this.stats.maxHp,this.hp+this.stats.regen); this.regenTimer=0; const dt=new DamageText(this.x,this.y,this.stats.regen,false); dt.color='#00a99c'; GS.damageTexts.push(dt); }
    }
    if(this.invulnTimer>0) this.invulnTimer-=GS.dt;
    if(Math.abs(this.x)>50000) this.x=0; if(Math.abs(this.y)>50000) this.y=0;
  }
  draw(){
    // 플레이어 무기 효과 먼저 그림
    this.weapons.forEach(w=>w.draw&&w.draw());

    if(this.invulnTimer>0 && Math.floor(GS.time*20)%2===0) return;

    const cx=C.WIDTH/2, cy=C.HEIGHT/2, ctx=GS.ctx;
    ctx.save(); ctx.translate(cx,cy);
    const ringAngle=GS.time*2; ctx.rotate(ringAngle);
    ctx.strokeStyle='rgba(0,169,156,0.65)'; ctx.lineWidth=3;
    Draw.glow('rgba(0,169,156,0.7)',12,0.8);
    ctx.beginPath(); ctx.arc(0,0,this.r*1.65,0,Math.PI*1.8); ctx.stroke();
    Draw.resetGlow(); ctx.restore();

    // 본체
    Draw.glow(C.COLORS.player,22);
    Draw.circle(this.x,this.y,this.r,C.COLORS.player,'#fff',2);
    Draw.resetGlow();

    // HP바
    const bw=40,bh=6;
    ctx.fillStyle=C.COLORS.hpBg; ctx.fillRect(C.WIDTH/2-bw/2,C.HEIGHT/2+this.r+5,bw,bh);
    ctx.fillStyle=C.COLORS.hp; ctx.fillRect(C.WIDTH/2-bw/2,C.HEIGHT/2+this.r+5,bw*(this.hp/this.stats.maxHp),bh);
  }
  takeDamage(amount){
    if(this.invulnTimer>0||GS.state!=='running') return;
    const dmg=Math.max(1, amount - this.stats.armor); this.hp-=dmg; this.invulnTimer=.5; GS.screenShake=5;
    const dt=new DamageText(this.x,this.y,dmg,false); dt.color='#ff85a2'; GS.damageTexts.push(dt);
    if(GS.audio) GS.audio.sfxHurt(); if(this.hp<=0) gameOver();
  }
  gainXp(amount){ this.xp+=amount; if(this.xp>=this.nextLevelXp){ this.xp-=this.nextLevelXp; this.levelUp(); } updateHud(); }
  levelUp(){
    this.level++; this.nextLevelXp=Math.floor(8 + this.level*4*(1+this.level*.03));
    if(GS.audio) GS.audio.sfxLevelUp(); GS.state='levelup'; generateUpgrades();
  }
  addWeapon(w){ this.weapons.push(w); w.level=1; }
}

/* ---------- 적 ---------- */
class Enemy extends Entity{
  constructor(cfg,x,y){
    super(x,y,cfg.r);
    const m = 1 + (GS.stageIndex*.65);
    this.hp=cfg.hp*m; this.maxHp=this.hp;
    this.damage=cfg.dmg*m; this.speed=cfg.speed*(1+GS.stageIndex*.1);
    this.xp=cfg.xp; this.color=cfg.color; this.kbResist=cfg.kbResist||0;
    this.vx=0; this.vy=0; this.flash=0; this.auraTimer=0; this.bobOffset=M.rand(0,Math.PI*2);
    this.shoots=cfg.shoots||false; if(this.shoots){ this.shootCd=cfg.shootCd||3; this.shootTimer=M.rand(1,this.shootCd); }
  }
  update(){
    if(GS.victoryInProgress) return;
    const a=M.angle(this.x,this.y,GS.player.x,GS.player.y);
    this.vx=M.lerp(this.vx, Math.cos(a)*this.speed, 5*GS.dt);
    this.vy=M.lerp(this.vy, Math.sin(a)*this.speed, 5*GS.dt);
    this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt;
    if(M.collides(this,GS.player)) GS.player.takeDamage(this.damage);
    if(this.flash>0) this.flash-=GS.dt; if(this.auraTimer>0) this.auraTimer-=GS.dt;
    if(M.distSq(this.x,this.y,GS.player.x,GS.player.y) > (C.WIDTH*2)**2) this.active=false;
    if(this.shoots){ this.shootTimer-=GS.dt; if(this.shootTimer<=0){ this.shoot(); this.shootTimer=this.shootCd; } }
  }
  shoot(){
    if(GS.audio) GS.audio.sfxEnemyShoot();
    const a=M.angle(this.x,this.y,GS.player.x,GS.player.y), speed=200;
    GS.enemyProjectiles.push(new EnemyProjectile(this.x,this.y,6,Math.cos(a)*speed,Math.sin(a)*speed,this.damage*.7,3,this.color));
  }
  draw(){
    const col=this.flash>0?'#fff':this.color, bob=Math.sin(GS.time*5+this.bobOffset)*2;
    Draw.circle(this.x,this.y+bob,this.r,col);
    Draw.circle(this.x-this.r/2,this.y+this.r/3+bob,this.r*.6,col);
    Draw.circle(this.x+this.r/2,this.y+this.r/3+bob,this.r*.6,col);
    const cx=this.x-GS.camera.x+C.WIDTH/2, cy=this.y-GS.camera.y+C.HEIGHT/2+bob, ctx=GS.ctx;
    if(cx>-this.r&&cx<C.WIDTH+this.r&&cy>-this.r&&cy<C.HEIGHT+this.r){
      ctx.strokeStyle='rgba(0,0,0,.5)'; ctx.lineWidth=2;
      const eyeX=this.r*.4, eyeY=this.r*.1, eyeW=this.r*.25;
      ctx.beginPath(); ctx.moveTo(cx-eyeX,cy-eyeY); ctx.lineTo(cx-eyeX+eyeW,cy+eyeY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx+eyeX,cy-eyeY); ctx.lineTo(cx+eyeX-eyeW,cy+eyeY); ctx.stroke();
    }
    if (this.name) {
      const y = this.y + bob - this.r - 12;
      const x = this.x;
      const nctx = GS.ctx;
      const sx = x - GS.camera.x + C.WIDTH / 2;
      const sy = y - GS.camera.y + C.HEIGHT / 2;

      nctx.save();
      nctx.font = "bold 18px 'DNFBitBit', sans-serif";
      nctx.textAlign = "center";

      // 바깥 어두운 테두리
      nctx.lineWidth = 5;
      nctx.strokeStyle = "rgba(0,0,0,0.85)";
      nctx.strokeText(this.name, sx, sy);

      // 안쪽 밝은 하이라이트 선
      nctx.lineWidth = 2;
      nctx.strokeStyle = "rgba(255,255,255,0.5)";
      nctx.strokeText(this.name, sx, sy);

      // 본문 채우기
      nctx.fillStyle = "#fffdf0";
      nctx.fillText(this.name, sx, sy);

      // 은은한 CRT 느낌 글로우
      nctx.shadowColor = "rgba(255,255,200,0.35)";
      nctx.shadowBlur = 3;

      nctx.restore();
    }
  }
  takeDamage(amount,isCrit,kb,ang){
    this.hp-=amount; this.flash=.1; GS.damageTexts.push(new DamageText(this.x,this.y,amount,isCrit));
    const kbf=Math.max(0,kb-this.kbResist); this.x+=Math.cos(ang)*kbf*GS.dt*2; this.y+=Math.sin(ang)*kbf*GS.dt*2; this.vx=0; this.vy=0;
    if(this.hp<=0) this.die();
  }
  die(){
    this.active=false; GS.kills++; GS.gems.push(new ExperienceOrb(this.x,this.y,this.xp));
    if(Math.random()<.05) GS.potions.push(new HealthPotion(this.x,this.y));
    updateHud();
  }
}
class StandardBoss extends Enemy{
  constructor(cfg,x,y){
    super(cfg,x,y); this.shootTimer=M.rand(2,4); this.shootCd=4; this.projectileSpeed=220*(1+(GS.stageIndex?GS.stageIndex*.2:0));
  }
  update(){
    super.update(); if(GS.victoryInProgress) return;
    this.shootTimer-=GS.dt; if(this.shootTimer<=0){ this.shoot(); this.shootTimer=this.shootCd+M.rand(-.5,.5); }
  }
  shoot(){
    if(GS.audio) GS.audio.playTone(300,'sawtooth',.3,.2);
    const spawn=(x,y,a,s)=>{ const p=new EnemyProjectile(x,y,7,Math.cos(a)*s,Math.sin(a)*s,this.damage,4,this.color); GS.enemyProjectiles.push(p); return p; };
    const dx=GS.player.x-this.x, dy=GS.player.y-this.y, ang=Math.atan2(dy,dx);
    if(GS.stageIndex===0){
      for(let i=-1;i<=1;i++) spawn(this.x,this.y, ang + i*.25, this.projectileSpeed);
    }else if(GS.stageIndex===1){
      for(let i=-3;i<=3;i++) spawn(this.x,this.y, ang + i*.2, this.projectileSpeed);
    }else if(GS.stageIndex===2){
      const n=12;
      for(let i=0;i<n;i++){ const a=(i*(Math.PI*2/n)) + (ang*.2); spawn(this.x,this.y,a,this.projectileSpeed*.9); }
    }
  }
  die(){
    this.active=false; GS.kills++;
    const xpNeeded=Math.max(1, GS.player.nextLevelXp*.8);
    GS.gems.push(new ExperienceOrb(this.x,this.y,xpNeeded));
    nextStage(); updateHud();
  }
}
class FinalBoss extends StandardBoss{
  constructor(cfg,x,y){ super(cfg,x,y); this.teleportTimer=5; this.shootTimer=2.5; this.summonTimer=8; this.projectileSpeed=250*(1+(GS.stageIndex?GS.stageIndex*.2:0)); }
  update(){
    super.update(); if(GS.victoryInProgress) return;
    this.teleportTimer-=GS.dt; if(this.teleportTimer<=0){ this.teleport(); this.teleportTimer=M.rand(4,6); }
    this.summonTimer-=GS.dt; if(this.summonTimer<=0){ this.summonMinions(); this.summonTimer=M.rand(7,10); }
  }
  teleport(){
    if(GS.audio) GS.audio.playTone(200,'sine',.5,.4,400);
    const a=M.rand(0,Math.PI*2), d=M.rand(200,C.WIDTH/2.5);
    this.x=GS.player.x+Math.cos(a)*d; this.y=GS.player.y+Math.sin(a)*d;
  }
  shoot(){
    if(GS.audio) GS.audio.playTone(440,'triangle',.2,.3,-100);
    const spawn=(x,y,a,s)=>{ const p=new EnemyProjectile(x,y,8,Math.cos(a)*s,Math.sin(a)*s,this.damage*.8,4,'#9400D3'); GS.enemyProjectiles.push(p); return p; };
    const dx=GS.player.x-this.x, dy=GS.player.y-this.y, ang=Math.atan2(dy,dx);
    const n=5, spread=.4;
    for(let i=0;i<n;i++){ const a=ang+M.lerp(-spread,spread, i/(n-1)); spawn(this.x,this.y,a,this.projectileSpeed*1.2); }
    setTimeout(()=>{
      if(!this.active) return;
      const wave=8; for(let i=0;i<wave;i++){ const a=(GS.time*3) + (i*(Math.PI*2/wave)); spawn(this.x,this.y,a,this.projectileSpeed*.8); }
    },500);
  }
  summonMinions(){
    if(GS.audio) GS.audio.playTone(150,'sawtooth',.8,.3);
    for(let i=0;i<3;i++){
      const a=M.rand(0,Math.PI*2), d=this.r+20, sx=this.x+Math.cos(a)*d, sy=this.y+Math.sin(a)*d;
      GS.enemies.push(new Enemy(E_DEFS[M.randInt(0,1)], sx, sy));
    }
  }
  die(){
    this.active=false; GS.kills++;
    const xpNeeded=Math.max(1, GS.player.nextLevelXp*1.0);
    GS.gems.push(new ExperienceOrb(this.x,this.y,xpNeeded)); updateHud();
    initiateVictorySequence(this.x,this.y);
  }
}

/* ---------- 적 및 스테이지 데이터 ---------- */
const E_DEFS = [
  {r:10,hp:10, speed:120,dmg:5,  xp:2,  color:C.COLORS.e1},
  {r:12,hp:20, speed:80, dmg:8,  xp:4,  color:C.COLORS.e2},
  {r:12,hp:40, speed:90, dmg:10, xp:5,  color:C.COLORS.e3},
  {r:10,hp:25, speed:150,dmg:12, xp:6,  color:C.COLORS.e4, kbResist:50, shoots:true, shootCd:3.5},
  {r:20,hp:250,speed:40, dmg:20, xp:30, color:C.COLORS.e5, kbResist:200},
];
const STAGE_BOSS_DEFS = [
  {r:35,hp:500,  speed:60,dmg:20,xp:0,color:'#FF9800', kbResist:600},
  {r:40,hp:1500, speed:65,dmg:25,xp:0,color:'#4CAF50', kbResist:700},
  {r:45,hp:4000, speed:70,dmg:30,xp:0,color:'#2196F3', kbResist:800},
  {r:50,hp:5000, speed:75,dmg:35,xp:0,color:'#673AB7', kbResist:900},
];

const STAGES = [
  { name:"소통과 복지", enemyTypes:[0,1] },
  { name:"교육과 취업", enemyTypes:[1,2,3] },
  { name:"시설, 학생 자치", enemyTypes:[2,3,4,0] },
  { name:"환경, 문화, 참여", enemyTypes:[0,1,2,3,4] }
];

const STAGE_SKILL_SETS={
  1:[ {base:Wand,name:"내 친구 드리미"}, {base:OrbitingBlade,name:"공약 RE;dream"}, {base:Boomerang,name:"JNU 소통 허브 구축"},
      {base:Beam,name:"JNU-패스 도입"}, {base:Axe,name:"DREAM 천원 샵"}, {base:Aura,name:"드림 장학금"} ],
  2:[ {base:Wand,name:"수강신청 대기 순번제"}, {base:OrbitingBlade,name:"JNU Career Camp"}, {base:Boomerang,name:"예산 의결 학생 참여제"},
      {base:Beam,name:"학점 인정 인턴십 확대"}, {base:Axe,name:"Dream 융합 트랙 가이드"}, {base:Aura,name:"학내 학생 공간 확보"} ],
  3:[ {base:Wand,name:"DREAM SPACE IN JNU"}, {base:OrbitingBlade,name:"학생회관 냉난방 시스템 확립"}, {base:Boomerang,name:"제2운동장 환경 개선"},
      {base:Beam,name:"DOR+MUNITY"}, {base:Axe,name:"교양동 프린터기 설치"}, {base:Aura,name:"주차 사전정산 시스템 도입"} ],
  4:[ {base:Wand,name:"친환경 허브 캠퍼스 프로젝트"}, {base:OrbitingBlade,name:"Green JNU Challenge"}, {base:Boomerang,name:"드림 포인트제"},
      {base:Beam,name:"모두의 출범식"}, {base:Axe,name:"문화의 날"}, {base:Aura,name:"드림"} ]
};

const POLICY_DATA = [
  { category:"소통과 복지", policies:[
      {name:"총학생회-학생 간 소통 채널 확대", desc:"카카오톡 채널, 인스타그램 DM, 정기적인 간담회를 통해 학우들의 목소리를 더 가까이에서 듣고 신속하게 피드백하겠습니다."},
      {name:"제휴 혜택의 양적, 질적 확대", desc:"교내 시설뿐만 아니라 학교 주변 상권(음식점, 카페, 스터디룸 등)과의 제휴를 늘려 실질적인 학생 할인 혜택을 강화하겠습니다."},
      {name:"통학버스 노선 현실화 및 증차", desc:"주요 거점 지역에 대한 통학버스 노선을 재검토하고, 이용 수요가 많은 시간대에 배차를 늘려 통학 불편을 해소하겠습니다."}
  ]},
  { category:"교육과 취업", policies:[
      {name:"주요 교양 강의 증설 및 대형 강의 분반 추진", desc:"졸업 필수 요건과 직결되거나, 학우들의 수요가 높은 핵심 교양 강의를 추가 개설하고, 수강 인원이 과도하게 많은 강의는 분반하여 학습의 질을 높겠습니다."},
      {name:"학과별 맞춤형 취업 지원 프로그램", desc:"전공별 특성에 맞는 현직자 멘토링, 자격증 스터디 그룹 지원, 기업 채용 설명회 유치 등을 통해 체계적인 취업 준비를 돕겠습니다."},
      {name:"공결 처리 시스템 전산화 및 간소화", desc:"예비군, 취업 면접, 병결 등 공결 신청 및 처리 과정을 온라인 시스템으로 일원화하여 불필요한 행정 절차를 줄이겠습니다."}
  ]},
  { category:"시설, 학생 자치", policies:[
      {name:"중앙도서관 및 단과대 열람실 환경 개선", desc:"노후화된 책상 및 의자를 교체하고, 콘센트 증설, 백색소음기 설치 등을 통해 면학 분위기를 개선하겠습니다."},
      {name:"학내 무인 복합기 및 보조배터리 대여 서비스 확충", desc:"학생회관, 단과대학 건물 등 접근성이 좋은 위치에 24시간 이용 가능한 무인 복합기와 보조배터리 대여 기기를 추가 설치하겠습니다."},
      {name:"학생회비 사용 내역 전면 공개 및 감사 시스템 강화", desc:"모든 학생회비의 예산 편성부터 집행, 결산까지의 과정을 분기별로 투명하게 공개하고, 외부 회계 감사를 도입하여 신뢰도를 높이겠습니다."}
  ]},
  { category:"환경, 문화, 참여", policies:[
      {name:"캠퍼스 클린 캠페인 및 분리수거함 개선", desc:"단순한 쓰레기통이 아닌 재활용 품목별로 명확히 구분된 분리수거함을 확충하고, 정기적인 '클린 캠퍼스 데이'를 운영하겠습니다."},
      {name:"대학 문화 축제 콘텐츠 다각화", desc:"유명 연예인 초청 공연 외에도, 학생 동아리 버스킹, 플리마켓, e-스포츠 대회, 학술제 등 모든 학우가 참여하고 즐길 수 있는 다채로운 프로그램을 기획하겠습니다."},
      {name:"총학생회 주관 행사 참여 '드림 마일리지' 도입", desc:"총학생회가 주최하는 각종 행사에 참여할 때마다 마일리지를 적립해주고, 이를 교내 식당 할인권이나 굿즈로 교환할 수 있는 제도를 만들어 학생 참여를 활성화하겠습니다."}
  ]}
];

const STAGE_PASSIVE_NAMES={
  1:{might:'학생 열정',speed:'발로 뛰기',area:'서귀포 통학버스 노선 확대',cd:'기획력 향상',amount:'팀 시너지',magnet:'소통력',health:'드림의 결속',regen:'휴식의 시간'},
  2:{might:'전공 지식',speed:'빠른 이력서 작성',area:'넓은 인맥',cd:'효율적인 시간 관리',amount:'자격증 추가',magnet:'취업 정보 수집',health:'강철 체력',regen:'힐링 스터디'},
  3:{might:'학생회관 냉난방 시스템 확립',speed:'빠른 하자 보수',area:'와이파이 증폭',cd:'정후문 환경 개선',amount:'CCTV 추가 설치',magnet:'민원 접수',health:'안전 제일',regen:'정기 점검'},
  4:{might:'문화적 영향력',speed:'축제 준비 가속',area:'다채로운 이벤트',cd:'빠른 무대 전환',amount:'앵콜 공연',magnet:'관객 유치',health:'분리수거함 증설',regen:'캠퍼스 정화'}
};
const STAGE_ENEMY_NAMES={
  1:["정보의 제약","소통 채널 부족","교통비 부담","물가 상승","등록금 부담","버스 노선 부족"],
  2:["수강신청 실패","트랙과정 정보 부족","취업 걱정","인턴십 경험 부족"],
  3:["학내 학생공간 부족","냉난방 시설 부족","프린터기 부족","기숙사 불편사항","정후문 불편사항","차량 혼잡"],
  4:["벌레 문제","환경 오염","에너지 낭비","학우들의 적은 관심","학우들 적은 참여율"]
};
const STAGE_BACKGROUNDS={1:['#fce4ec','#fffde7'], 2:['#e3f2fd','#f3e5f5'], 3:['#fff8e1','#fff3e0'], 4:['#e8f5e9','#ede7f6']};

/* ---------- 시스템 ---------- */
function updatePassiveNames(stageNum){
  const map=STAGE_PASSIVE_NAMES[stageNum]; if(!map) return;
  PASSIVE_POOL.forEach(p=>{ if(map[p.id]) p.name=map[p.id]; });
}
function nextStage(){
  if(GS._stageTransitioning) return;
  GS._stageTransitioning=true;
  if(GS.stageIndex>=STAGES.length-1) return;
  GS.stageIndex++;
  const stage=STAGES[GS.stageIndex]; GS.bossHasSpawned=false;
  GS.stageTitle={text:`STAGE ${GS.stageIndex+1} - ${stage.name}`, timer:2.5};
  updatePassiveNames(GS.stageIndex+1);
  const set=STAGE_SKILL_SETS[GS.stageIndex+1]; if(set){ GS.player.weapons.forEach(w=>{ const m=set.find(s=>w instanceof s.base); if(m) w.name=m.name; }); }
  const names=STAGE_ENEMY_NAMES[GS.stageIndex+1]; if(names) GS.currentEnemyNames=names;
  const bg=STAGE_BACKGROUNDS[GS.stageIndex+1]; if(bg) GS.currentBg=bg;
  /* ✅ 최적화: 스테이지 전환 후 그라디언트를 강제로 재캐싱 */
  GS.gradientCache=null;
  setTimeout(()=>{GS._stageTransitioning=false;},2000);
}
/* ✅ 최적화: 배경 그라디언트를 스테이지마다 한 번만 캐싱 */
Draw.background=function(){
  // 스테이지마다 그라디언트를 한 번만 캐싱
  if(!GS.gradientCache){
    GS.gradientCache = GS.ctx.createLinearGradient(0,0,0,C.HEIGHT);
    GS.gradientCache.addColorStop(0, "#b8e0d8");
    GS.gradientCache.addColorStop(1, "#eafcf7");
  }
  GS.ctx.fillStyle = GS.gradientCache;
  GS.ctx.fillRect(0,0,C.WIDTH,C.HEIGHT);
};
function spawnBoss(bossDef,isFinal=false){
  if(GS.audio) GS.audio.playTone(80,'sawtooth',1.0,.4);
  GS.bossAlert={text:'!!! BOSS ALERT !!!', life:3};
  const a=M.rand(0,Math.PI*2), d=C.WIDTH/2+100, x=GS.player.x+Math.cos(a)*d, y=GS.player.y+Math.sin(a)*d;
  let boss = isFinal ? new FinalBoss(bossDef,x,y) : new StandardBoss(bossDef,x,y);
  const mult=1+GS.stageIndex*.4; boss.damage*=mult; if(isFinal) boss.damage*=.5;
  if(boss.attackCooldown!==undefined) boss.attackCooldown=Math.max(.3, boss.attackCooldown-GS.stageIndex*.2);
  if(boss.projectileSpeed!==undefined) boss.projectileSpeed*=1+GS.stageIndex*.2;
  boss.speed*=Math.min(1.3, 1+GS.stageIndex*.05);
  GS.enemies.push(boss);
}
function checkCollisions(){
  const enemies=GS.enemies;
  if(enemies.length===0) return;
  for(const p of GS.projectiles){
    if(!p.active) continue;
    const px=p.x, py=p.y, pr=p.r;
    for(const e of enemies){
      if(!e.active) continue;
      if(p.hitList.includes(e)) continue;
      const sumR = pr + e.r;
      const dx = px - e.x;
      if(Math.abs(dx) > sumR) continue;
      const dy = py - e.y;
      if(Math.abs(dy) > sumR) continue;
      if(M.distSq(px,py,e.x,e.y) <= sumR*sumR){
        p.onHit(e); p.hitList.push(e);
        if(!p.active) break;
      }
    }
  }
}
function generateUpgrades(){
  const container=document.getElementById('upgradeContainer'); container.innerHTML='';
  document.getElementById('levelUpScreen').classList.remove('hidden');
  let options=[];
  GS.player.weapons.forEach(w=>{ if(w.level < w.maxLevel) options.push({type:'weapon_up', obj:w}); });
  if(GS.player.weapons.length<6){
    WEAPON_POOL.forEach(Cls=>{
      if(!GS.player.weapons.some(w=>w instanceof Cls)) options.push({type:'weapon_new', cls:Cls});
    });
  }
  PASSIVE_POOL.forEach(p=>{
    const lvl=GS.player.passives[p.id]||0; if(lvl<5) options.push({type:'passive', def:p, lvl});
  });
  if(options.length===0) options.push({type:'heal'});
  options.sort(()=>Math.random()-.5);
  const luckBonus = GS.player.stats.luck>1.2 ? 1 : 0;
  const choices = options.slice(0, Math.min(3+luckBonus, options.length));
  choices.forEach(choice=>{
    const card=document.createElement('div'); card.className='upgrade-card';
    let title,desc,typeStr,iconCol,isNew=false;
    if(choice.type==='weapon_up'){
      title=`${choice.obj.name} (Lv ${choice.obj.level+1})`; desc=choice.obj.getDescription(); typeStr='WEAPON UPGRADE'; iconCol=choice.obj.iconColor;
    }else if(choice.type==='weapon_new'){
      const temp=new choice.cls(); const current=STAGE_SKILL_SETS[GS.stageIndex+1]; const info=current?.find(s=>s.base===choice.cls);
      title = info? info.name : temp.name; desc=temp.getDescription(); typeStr='NEW WEAPON'; iconCol=temp.iconColor; isNew=true;
    }else if(choice.type==='passive'){
      title=`${choice.def.name} (Lv ${choice.lvl+1})`; desc=choice.def.desc; typeStr='PASSIVE'; iconCol=choice.def.icon; if(choice.lvl===0) isNew=true;
    }else{ title='달콤한 휴식'; desc='체력 30% 회복'; typeStr='CONSUMABLE'; iconCol='#f88'; }
    card.innerHTML=`
      <div class="upgrade-icon" style="background:${iconCol}"></div>
      <div class="upgrade-title">${title}</div>
      <div class="upgrade-type">${typeStr}</div>
      <div class="upgrade-desc">${desc}</div>
      ${isNew?'<div class="new-tag">NEW!</div>':''}
    `;
    card.onclick=()=>selectUpgrade(choice);
    container.appendChild(card);
  });
}
function selectUpgrade(choice){
  if(GS.audio) GS.audio.playTone(880,'sine',.1,.5);
  if(choice.type==='weapon_up'){ choice.obj.level++; }
  else if(choice.type==='weapon_new'){
    const w=new choice.cls(); const set=STAGE_SKILL_SETS[GS.stageIndex+1]; const info=set?.find(s=>w instanceof s.base); if(info) w.name=info.name; GS.player.addWeapon(w);
  }else if(choice.type==='passive'){
    choice.def.apply(GS.player.stats); GS.player.passives[choice.def.id]=(GS.player.passives[choice.def.id]||0)+1;
  }else if(choice.type==='heal'){ GS.player.hp=Math.min(GS.player.stats.maxHp, GS.player.hp + GS.player.stats.maxHp*.3); }
  document.getElementById('levelUpScreen').classList.add('hidden'); GS.state='running'; GS.lastTime=performance.now();
}

/* ---------- 게임 진행 ---------- */
function initiateVictorySequence(x,y){
  GS.victoryInProgress=true; GS.enemies=[];
  let duration=2500, interval=100, elapsed=0;
  const id=setInterval(()=>{
    GS.screenShake = 20*(1-(elapsed/duration));
    spawnParticles(x,y,C.COLORS.xp1,30); spawnParticles(x,y,C.COLORS.xp3,15); if(GS.audio) GS.audio.sfxHit();
    elapsed+=interval;
  }, interval);
  setTimeout(()=>{ clearInterval(id); GS.screenShake=0; GS.victoryInProgress=false; victory(); }, duration);
}
function spawnEnemies(){
  if(GS.victoryInProgress) return;
  if(GS.player.level >= (GS.stageIndex+1)*5 && !GS.bossHasSpawned){
    GS.bossHasSpawned=true; const def=STAGE_BOSS_DEFS[GS.stageIndex]; const isFinal = GS.stageIndex===STAGE_BOSS_DEFS.length-1; spawnBoss(def,isFinal); return;
  }
  if(GS.bossHasSpawned) return;
  GS.spawnTimer-=GS.dt; if(GS.spawnTimer<=0){
    const spawnInterval=Math.max(.05, .4 - (GS.player.level*.025) - (GS.stageIndex*.1)); GS.spawnTimer=spawnInterval;
    const stage=STAGES[GS.stageIndex], list=stage.enemyTypes;
    const type=list[M.randInt(0,list.length-1)];
    const def=E_DEFS[type];
    if(def.shoots && Math.random()>.15) return;
    /* ✅ 최적화: 난이도 곡선을 유지하며 기기별 동시 적 수 제한 */
    if(GS.enemies.length >= DEVICE.enemyCap) return;
    const angle=M.rand(0,Math.PI*2);
    const radius=Math.hypot(C.WIDTH*0.5,C.HEIGHT*0.5)+50;
    const px=GS.player.x, py=GS.player.y;
    const x=px+Math.cos(angle)*radius;
    const y=py+Math.sin(angle)*radius;
    const enemy=new Enemy(def,x,y);
    if(GS.currentEnemyNames) enemy.name=GS.currentEnemyNames[M.randInt(0,GS.currentEnemyNames.length-1)];
    GS.enemies.push(enemy);
  }
}
function drawStageTitle(){
  if(GS.stageTitle && GS.stageTitle.timer>0){
    const a=Math.min(1, GS.stageTitle.timer); GS.ctx.globalAlpha=a;
    Draw.text(GS.stageTitle.text, GS.player.x, GS.player.y - C.HEIGHT/3, 24, '#003d38', 'center');
    GS.ctx.globalAlpha=1; GS.stageTitle.timer-=GS.dt;
  }
}

/* ---------- 루프 및 HUD ---------- */
function update(){
  if(GS.time >= 180 && !GS.gameOver){ GS.gameOver=true; endGame("시간 초과! 3분 내 클리어 실패"); return; }
  spawnEnemies();
  GS.player.update();

  // 파티클 업데이트 최적화: 모바일에서 처리량 제한
  const maxParticles = DEVICE.isMobile ? 50 : GS.particles.length;
  for (let i = 0; i < maxParticles && i < GS.particles.length; i++) {
    GS.particles[i].update();
  }
  // 비활성 파티클을 배열에서 제거하며 제자리 압축
  let pw = 0;
  for (let i = 0; i < GS.particles.length; i++) {
    if (GS.particles[i].active) GS.particles[pw++] = GS.particles[i];
  }
  GS.particles.length = pw;

  // 나머지 엔티티는 기존 방식대로 처리
  stepEntities(GS.enemies);
  stepEntities(GS.projectiles);
  stepEntities(GS.enemyProjectiles);
  stepEntities(GS.gems);
  stepEntities(GS.potions);
  stepEntities(GS.damageTexts);
  checkCollisions();
  if(GS.screenShake>0) GS.screenShake -= GS.dt*20;
  if(GS.bossAlert.life>0) GS.bossAlert.life -= GS.dt;
}
function render(){
  const ctx=GS.ctx; ctx.save();
  if(GS.screenShake>0) ctx.translate(M.rand(-GS.screenShake,GS.screenShake), M.rand(-GS.screenShake,GS.screenShake));

  // CPU 배칭: 모바일은 정적 배경 버퍼, 그 외엔 그라디언트 렌더
  if (DEVICE.isMobile) {
    if (!GS.bgBuffer || GS.bgBuffer.width !== C.WIDTH || GS.bgBuffer.height !== C.HEIGHT) {
      GS.bgBuffer = document.createElement("canvas");
      GS.bgBuffer.width = C.WIDTH;
      GS.bgBuffer.height = C.HEIGHT;
      const bctx = GS.bgBuffer.getContext("2d");
      bctx.fillStyle = "#e6f5f2";
      bctx.fillRect(0, 0, C.WIDTH, C.HEIGHT);
    }
    ctx.drawImage(GS.bgBuffer, 0, 0);
  } else {
    Draw.background();
  }

  const player = GS.player;
  const px = player.x, py = player.y;
  const xCull = DEVICE.cullX, yCull = DEVICE.cullY;
  const withinView = (ox,oy)=> Math.abs(ox - px) <= xCull && Math.abs(oy - py) <= yCull;
  // 오브젝트 렌더링 루프: 900/600 거리 필터 추가
  for(const e of GS.gems){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const p of GS.potions){ if(!withinView(p.x,p.y)) continue; p.draw(); }
  for(const e of GS.particles){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  // ✅ CPU 정렬 오버헤드 절감
  if (GS.enemies.length > 1 && (GS.frameCount % 3 === 0)) {
    GS.enemies.sort((a, b) => a.y - b.y);
  }
  for(const e of GS.enemies){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  player.draw();
  for(const e of GS.projectiles){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const e of GS.enemyProjectiles){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const e of GS.damageTexts){ if(!withinView(e.x,e.y)) continue; e.draw(); }

  // 모바일에서는 비네트를 제거
  if (!DEVICE.isMobile) {
    const grad = GS.ctx.createRadialGradient(C.WIDTH / 2, C.HEIGHT / 2, C.HEIGHT / 2, C.WIDTH / 2, C.HEIGHT / 2, C.WIDTH / 1.5);
    grad.addColorStop(0, 'transparent');
    grad.addColorStop(1, 'rgba(0,0,0,.1)');
    GS.ctx.fillStyle = grad;
    GS.ctx.fillRect(0, 0, C.WIDTH, C.HEIGHT);
  }

  if(GS.bossAlert.life>0){
    const alpha=Math.min(1,GS.bossAlert.life), size=40+(3-GS.bossAlert.life)*5; ctx.globalAlpha=alpha;
    Draw.text(GS.bossAlert.text, GS.player.x, GS.player.y - C.HEIGHT/3, size, '#b30000'); ctx.globalAlpha=1;
  }
  // 스테이지 텍스트 폰트 크기 모바일에서 30% 축소
  const fontSize = innerWidth < 768 ? Math.floor(16 * 0.7) : 16;
  ctx.font = `${fontSize}px 'Press Start 2P'`; ctx.textAlign="center"; ctx.fillStyle="#003d38"; ctx.strokeStyle="#fff"; ctx.lineWidth=4;
  const stageName=STAGES[GS.stageIndex]?.name||"", stageText=`STAGE ${GS.stageIndex+1} - ${stageName}`, x=C.WIDTH/2, y=85; ctx.strokeText(stageText,x,y); ctx.fillText(stageText,x,y);
  drawStageTitle(); ctx.restore();
}
function updateHud(){
  const p=GS.player;
  if(!p) return;
  const xpPct=(p.xp/p.nextLevelXp)*100;
  if(HUD.xpBar) HUD.xpBar.style.width = `${xpPct}%`;
  // 레벨 텍스트 폰트 크기 모바일에서 30% 축소
  const fontSize = innerWidth < 768 ? 10 : 14;
  if(HUD.levelText){
    HUD.levelText.style.fontSize = `${fontSize}px`;
    HUD.levelText.innerText = `LV ${p.level}`;
  }
  if(HUD.timer) HUD.timer.innerText = M.formatTime(GS.time);
  if(HUD.killCount) HUD.killCount.innerText = `✨ ${GS.kills}`;
}
function gameLoop(t = performance.now()) {
  // ✅ 첫 프레임 안정화
  if (!GS.lastTime) GS.lastTime = t;
  let raw = (t - GS.lastTime) / 1000;
  GS.lastTime = t;

  // 적응형 프레임 페이싱: 델타를 부드럽게 처리하고 FPS 제한 없음
  if (DEVICE.isMobile) raw = Math.min(Math.max(raw, 0.01), 0.025);
  else raw = Math.min(Math.max(raw, 0.008), 0.033);
  GS.smoothedDt = GS.smoothedDt ? (GS.smoothedDt * 0.9 + raw * 0.1) : raw;
  GS.dt = GS.smoothedDt;

  // 저성능 상태 감지
  if (!GS.lowPerfCounter) GS.lowPerfCounter = 0;
  if (raw > 0.035) GS.lowPerfCounter++;
  else GS.lowPerfCounter = Math.max(0, GS.lowPerfCounter - 1);
  GS.lowPerfMode = GS.lowPerfCounter > 5;

  if (GS.state === 'running') {
    GS.time += GS.dt;
    GS.frameCount++;
    update();
    render();
    updateHud();
  } else {
    // 일시정지·메뉴 상태에서도 UI 반응성을 유지하기 위해 계속 렌더링
    render();
  }

  requestAnimationFrame(gameLoop);
}

/* ---------- 게임 상태 ---------- */
function initGame(){
  GS.player=new Player(); GS.enemies=[]; GS.projectiles=[]; GS.enemyProjectiles=[]; GS.gems=[]; GS.particles=[]; GS.damageTexts=[]; GS.potions=[];
  GS.particlePool=[];
  // 모바일에서는 파티클 풀 크기를 축소
  const particlePoolSize = DEVICE.isMobile ? 100 : DEVICE.particleCap;
  for(let i=0;i<particlePoolSize;i++) GS.particlePool.push(new Particle(0,0,'#fff',0,0,0));
  GS.time=0; GS.kills=0; GS.camera={x:0,y:0}; GS.spawnTimer=1.8; GS.bossAlert={text:'',life:0};
  GS.startTime=null; GS.gameOver=false; GS.victoryInProgress=false; GS.stageIndex=0;
  const initial=STAGES[GS.stageIndex]; GS.stageTitle={text:`STAGE 1 - ${initial.name}`, timer:2.5};
  GS.currentBg=STAGE_BACKGROUNDS[GS.stageIndex+1];
  /* ✅ 최적화: 재시작 시 캐시된 그라디언트 초기화 */
  GS.gradientCache=null;
  GS.bossHasSpawned=false; GS.level5BossTriggered=false; GS.level10BossTriggered=false; GS.level15BossTriggered=false; GS.level20BossTriggered=false;
  GS.currentEnemyNames=STAGE_ENEMY_NAMES[GS.stageIndex+1];
  updatePassiveNames(1);
  const set=STAGE_SKILL_SETS[1]; if(set){ GS.player.weapons.forEach(w=>{ const s=set.find(x=>w instanceof x.base); if(s) w.name=s.name; }); }
  if(!GS.audio) GS.audio=new AudioSys(); GS.audio.ctx.resume();
  GS.state='running'; GS.lastTime=performance.now();
  // ✅ 비주얼과 파티클에 적응형 스케일링 적용
  GS.glowIntensity = 1 * PERF.score;
  GS.particleDensity = 1 * PERF.score;
  GS.enemySpawnRate = 1 * PERF.score;
  document.querySelectorAll('.overlay').forEach(el=>el.classList.add('hidden'));
  setupJoystick();
  requestAnimationFrame(gameLoop);
}
function togglePause(){
  if(GS.state==='running'){
    GS.state='paused'; document.getElementById('pauseMenu').classList.remove('hidden');
    let html='<h3>Weapons</h3>'; GS.player.weapons.forEach(w=> html += `<p style="color:${w.iconColor}">${w.name}: Lv ${w.level}</p>`);
    html+='<h3>Stats</h3>'; const s=GS.player.stats;
    html+=`<p>Might: ${Math.round(s.might*100)}%</p><p>Speed: ${s.moveSpeed}</p><p>Cooldown: ${Math.round(s.cooldown*100)}%</p>`;
    document.getElementById('statsContainer').innerHTML=html;
  }else if(GS.state==='paused'){
    GS.state='running'; document.getElementById('pauseMenu').classList.add('hidden'); GS.lastTime=performance.now();
  }
}
function gameOver(){
  GS.state='gameover'; if(GS.audio) GS.audio.sfxDie();
  // 폰트 크기 모바일에서 30% 축소
  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('goTitle').style.fontSize = `${Math.floor(32 * (innerWidth < 768 ? 0.7 : 1))}px`;
  document.getElementById('goTime').style.fontSize = `${fontSize}px`;
  document.getElementById('goKills').style.fontSize = `${fontSize}px`;
  document.getElementById('goLevel').style.fontSize = `${fontSize}px`;
  document.getElementById('goTitle').innerText="꿈속에 갇혔습니다...";
  document.getElementById('goTime').innerText=`버틴 시간: ${M.formatTime(GS.time)}`;
  document.getElementById('goKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('goLevel').innerText=`성장 레벨: ${GS.player.level}`;
  setTimeout(()=> document.getElementById('gameOverScreen').classList.remove('hidden'), 1000);
}
function endGame(msg){
  GS.state='gameover'; if(GS.audio) GS.audio.sfxDie();
  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('goTitle').style.fontSize = `${Math.floor(32 * (innerWidth < 768 ? 0.7 : 1))}px`;
  document.getElementById('goTime').style.fontSize = `${fontSize}px`;
  document.getElementById('goKills').style.fontSize = `${fontSize}px`;
  document.getElementById('goLevel').style.fontSize = `${fontSize}px`;
  document.getElementById('goTitle').innerText=msg||"꿈속에 갇혔습니다...";
  document.getElementById('goTime').innerText=`버틴 시간: ${M.formatTime(GS.time)}`;
  document.getElementById('goKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('goLevel').innerText=`성장 레벨: ${GS.player.level}`;
  setTimeout(()=> document.getElementById('gameOverScreen').classList.remove('hidden'), 1000);
}
function victory(){
  if(GS.state==='victory') return; GS.state='victory'; GS.enemies=[];
  // 폰트 크기 모바일에서 30% 축소
  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('vKills').style.fontSize = `${fontSize}px`;
  document.getElementById('vKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('victoryScreen').classList.remove('hidden');
}

/* ---------- 입력 ---------- */
addEventListener('keydown',e=>{
  const k=e.key.toLowerCase(); if('wasd'.includes(k)||k.startsWith('arrow')){
    if(k==='w'||k==='arrowup') GS.input.up=true;
    if(k==='s'||k==='arrowdown') GS.input.down=true;
    if(k==='a'||k==='arrowleft') GS.input.left=true;
    if(k==='d'||k==='arrowright') GS.input.right=true;
  }
  if(k==='p'||k==='escape'){ if(GS.state==='running'||GS.state==='paused') togglePause(); }
});
addEventListener('keyup',e=>{
  const k=e.key.toLowerCase(); if('wasd'.includes(k)||k.startsWith('arrow')){
    if(k==='w'||k==='arrowup') GS.input.up=false;
    if(k==='s'||k==='arrowdown') GS.input.down=false;
    if(k==='a'||k==='arrowleft') GS.input.left=false;
    if(k==='d'||k==='arrowright') GS.input.right=false;
  }
});

/* ---------- UI 버튼 ---------- */
document.getElementById('btnStart').onclick = initGame;
document.getElementById('btnRestart').onclick=initGame;
document.getElementById('btnRestartVic').onclick=initGame;
document.getElementById('btnResume').onclick=togglePause;

/* ---------- 정책 모달 ---------- */
function showPolicy(){ document.getElementById('policyScreen').classList.remove('hidden'); }
function hidePolicy(){ document.getElementById('policyScreen').classList.add('hidden'); }
function populatePolicyModal(){
  const container=document.getElementById('policyListContainer'); let html='';
  POLICY_DATA.forEach(cat=>{
    html+=`<h3>[ ${cat.category} ]</h3>`;
    if(cat.policies){ html+='<ul>'; cat.policies.forEach(p=>{ html+=`<li><strong>- ${p.name}</strong><p class="policy-desc">${p.desc||''}</p></li>`; }); html+='</ul>'; }
  });
  container.innerHTML=html;
}
document.getElementById('btnPolicyGO').onclick=showPolicy;
document.getElementById('btnPolicyVic').onclick=showPolicy;
document.getElementById('btnClosePolicy').onclick=hidePolicy;
populatePolicyModal();

/* ---------- 캔버스 부트스트랩 ---------- */
// 고 DPI 환경에 맞춰 캔버스 크기 초기화
resize();
Draw.background();

/* ---------- 가상 조이스틱(모바일) ---------- */
function setupJoystick(){
  const base=document.getElementById('joystick-base'), thumb=document.getElementById('joystick-thumb');
  const ua = navigator.userAgent;
  const isTouchDevice = (
    'ontouchstart' in window ||
    navigator.maxTouchPoints > 0 ||
    navigator.msMaxTouchPoints > 0 ||
    /iPad|Tablet|PlayBook|Silk/i.test(ua) ||
    (/Macintosh/i.test(ua) && 'ontouchend' in document) ||
    window.matchMedia && window.matchMedia('(pointer:coarse)').matches
  );
  if (isTouchDevice) base.style.display = 'block';
  let active=false, rect=base.getBoundingClientRect();
  const refresh=()=> rect=base.getBoundingClientRect();
  addEventListener('resize',refresh); addEventListener('orientationchange',refresh);
  if(!GS.player) GS.player={}; if(!GS.player.moveDir) GS.player.moveDir={x:0,y:0};
  base.addEventListener('touchstart',()=>{ active=true; refresh(); });
  base.addEventListener('touchmove',e=>{
    if(!active) return; const t=e.touches[0];
    const x=t.clientX-(rect.left+rect.width/2), y=t.clientY-(rect.top+rect.height/2);
    const dist=Math.sqrt(x*x+y*y), max=rect.width/2-10;
    const nx=M.clamp(x/max,-1,1), ny=M.clamp(y/max,-1,1); GS.player.moveDir={x:nx,y:ny};
    thumb.style.transform=`translate(${nx*max*0.5}px, ${ny*max*0.5}px)`;
  },{passive:true});
  base.addEventListener('touchend',()=>{ active=false; GS.player.moveDir={x:0,y:0}; thumb.style.transform='translate(0,0)'; });
}

/* 모바일 조이스틱 대응을 위한 Player.update 패치 */
(function(){
  const ua = navigator.userAgent;
  const isTouchDevice =
  'ontouchstart' in window ||
  navigator.maxTouchPoints > 0 ||
  navigator.msMaxTouchPoints > 0 ||
  /iPad|Tablet|PlayBook|Silk/i.test(ua) ||
  (/Macintosh/i.test(ua) && 'ontouchend' in document);
  if (!isTouchDevice) return;  
  const orig=Player.prototype.update;
  Player.prototype.update=function(){
    if(GS.victoryInProgress) return;
    let dx=0, dy=0;
    if(this.moveDir && (this.moveDir.x||this.moveDir.y)){ dx=this.moveDir.x; dy=this.moveDir.y; }
    else{ if(GS.input.up)dy-=1; if(GS.input.down)dy+=1; if(GS.input.left)dx-=1; if(GS.input.right)dx+=1; }
    if(dx&&dy){ const k=.7071; dx*=k; dy*=k; }
    this.x+=dx*this.stats.moveSpeed*GS.dt; this.y+=dy*this.stats.moveSpeed*GS.dt; if(dx!==0) this.facing=Math.sign(dx);
    GS.camera.x=M.lerp(GS.camera.x,this.x,10*GS.dt); GS.camera.y=M.lerp(GS.camera.y,this.y,10*GS.dt);
    this.weapons.forEach(w=>w.update());
    if(this.hp<this.stats.maxHp && this.stats.regen>0){
      this.regenTimer+=GS.dt; if(this.regenTimer>=1){ this.hp=Math.min(this.stats.maxHp,this.hp+this.stats.regen); this.regenTimer=0;
        const dt=new DamageText(this.x,this.y,this.stats.regen,false); dt.color='#00a99c'; GS.damageTexts.push(dt);
      }
    }
    if(this.invulnTimer>0) this.invulnTimer-=GS.dt;
    if(Math.abs(this.x)>50000) this.x=0; if(Math.abs(this.y)>50000) this.y=0;
  };
})();

</script>
</body>
</html>
