<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Dream Survivors</title>

<!-- 폰트 -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2107@1.1/DungGeunMo.woff" rel="stylesheet" as="font" type="font/woff" crossorigin>
<link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.1/DNFBitBit.woff" rel="stylesheet" as="font" type="font/woff" crossorigin>

<style>
  :root{
    --brand:#00d4c4;
    --brand-d:#00a99c;
    --brand-bright:#00ffe8;
    --ink:#002e2a;
    --bg-a:#e8f8f5;
    --bg-b:#cef3ed;
    --white:#ffffff;
    --shadow-soft:0 4px 20px rgba(0,169,156,0.15);
    --shadow-strong:0 8px 30px rgba(0,169,156,0.25);
    --safe-top:env(safe-area-inset-top, 0px);
    --safe-bottom:env(safe-area-inset-bottom, 0px);
    --safe-left:env(safe-area-inset-left, 0px);
    --safe-right:env(safe-area-inset-right, 0px);
    --footer-banner-offset:calc(60px + var(--safe-bottom));
    --stage-bg-top:#b8e0d8;
    --stage-bg-bottom:#eafcf7;
  }

  /* 기본 스타일 */
  *{box-sizing:border-box}
  html,body{height:100%}
  html{
    background:linear-gradient(180deg,var(--stage-bg-top) 0%,var(--stage-bg-bottom) 100%);
    background-color:var(--stage-bg-bottom);
  }
  body{
    margin:0;padding:0;overflow:hidden;
    min-height:100vh;
    background:linear-gradient(180deg,var(--stage-bg-top) 0%,var(--stage-bg-bottom) 100%);
    background-color:var(--stage-bg-bottom);
    font-family:'Press Start 2P',cursive;color:var(--ink); user-select:none;
  }
  #footerBanner{
    width:100%;
    text-align:center;
    padding:0.8rem 1rem calc(0.8rem + var(--safe-bottom));
    background:linear-gradient(90deg,#00bfa5,#0097a7);
    color:#fff;
    font-weight:600;
    font-size:clamp(0.9rem,2vw,1.1rem);
    border-top-left-radius:10px;
    border-top-right-radius:10px;
    box-shadow:0 -3px 10px rgba(0,0,0,0.1);
    position:fixed;
    bottom:0;
    left:0;
    right:0;
    z-index:1000;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  #gameCanvas{
    display:block;
    box-shadow:0 0 60px rgba(0,212,196,0.3), inset 0 0 100px rgba(0,0,0,0.1);
  }

  /* 오버레이 */
  .overlay{
    position:absolute; inset:0; display:flex; flex-direction:column;
    justify-content:center; align-items:center; text-align:center; z-index:10;
    background:linear-gradient(135deg, rgba(0,50,45,0.95), rgba(0,80,75,0.9));
    backdrop-filter:blur(10px); color:#fff;
    animation:fadeIn 0.3s ease-out;
    padding:calc(var(--safe-top) + 20px) calc(var(--safe-right) + 20px) calc(var(--footer-banner-offset) + 20px) calc(var(--safe-left) + 20px);
  }
  @keyframes fadeIn{
    from{opacity:0; transform:scale(0.95)}
    to{opacity:1; transform:scale(1)}
  }
  .hidden{display:none!important}

  /* 타이포그래피 */
  h1{
    color:var(--brand-bright);
    text-shadow:0 0 20px rgba(0,255,232,0.5), 3px 3px 0 rgba(0,169,156,0.8), 6px 6px 0 rgba(0,100,90,0.4);
    font-size:48px; margin:0 0 20px;
    animation:glow 2s ease-in-out infinite alternate;
  }
  @keyframes glow{
    from{text-shadow:0 0 20px rgba(0,255,232,0.5), 3px 3px 0 rgba(0,169,156,0.8)}
    to{text-shadow:0 0 30px rgba(0,255,232,0.8), 3px 3px 0 rgba(0,169,156,1), 0 0 40px rgba(0,212,196,0.3)}
  }
  h2{color:var(--brand-bright); text-shadow:0 0 10px rgba(0,255,232,0.6), 2px 2px 0 rgba(0,169,156,0.8); margin:0 0 30px}
  p{line-height:1.6; font-size:14px; color:#cef3ed; max-width:600px; margin:10px auto; text-shadow:1px 1px 2px rgba(0,0,0,0.5)}

  /* 버튼 */
  button{
    background:linear-gradient(135deg, var(--brand) 0%, var(--brand-d) 100%);
    color:#fff; border:0; border-bottom:4px solid #006b62;
    padding:15px 30px; font:16px 'Press Start 2P',cursive; cursor:pointer; margin:10px;
    transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius:12px;
    text-shadow:1px 1px 2px rgba(0,0,0,.3);
    box-shadow:0 4px 15px rgba(0,169,156,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
    position:relative;
    overflow:hidden;
  }
  button::before{
    content:'';
    position:absolute;
    top:0; left:-100%;
    width:100%; height:100%;
    background:linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    transition:left 0.5s;
  }
  button:hover::before{
    left:100%;
  }
  button:hover{
    background:linear-gradient(135deg, var(--brand-bright) 0%, var(--brand) 100%);
    transform:translateY(-3px);
    border-bottom-width:6px;
    box-shadow:0 6px 25px rgba(0,212,196,0.6), inset 0 1px 0 rgba(255,255,255,0.3);
  }
  button:active{
    transform:translateY(1px);
    border-bottom-width:2px;
    box-shadow:0 2px 10px rgba(0,169,156,0.4);
  }

  /* HUD 영역 */
  #hud{
    position:absolute; inset:0 auto auto 0; width:100%;
    padding:calc(15px + var(--safe-top)) calc(15px + var(--safe-right)) calc(15px + var(--footer-banner-offset)) calc(15px + var(--safe-left));
    pointer-events:none; z-index:5;
  }
  .xp-container{
    width:100%; height:26px;
    background:linear-gradient(135deg, rgba(0,50,45,0.8), rgba(0,80,75,0.6));
    border:3px solid rgba(0,212,196,0.6);
    border-radius:15px; position:relative;
    box-shadow:0 4px 20px rgba(0,0,0,0.3), inset 0 2px 10px rgba(0,0,0,0.2);
    backdrop-filter:blur(5px);
  }
  #xpBar{
    height:100%; width:0%; transition:width .3s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius:12px;
    background:linear-gradient(90deg, var(--brand-d), var(--brand), var(--brand-bright));
    box-shadow:0 0 15px var(--brand-bright), inset 0 2px 5px rgba(255,255,255,0.3);
    position:relative;
    overflow:hidden;
  }
  #xpBar::after{
    content:'';
    position:absolute;
    top:0; left:0; right:0; bottom:0;
    background:linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation:shimmer 2s infinite;
  }
  @keyframes shimmer{
    0%{transform:translateX(-100%)}
    100%{transform:translateX(100%)}
  }
  #levelText{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    color:#fff; font-size:13px;
    text-shadow:0 0 10px rgba(0,255,232,0.8), 2px 2px 4px rgba(0,0,0,0.8);
    font-weight:bold;
  }
  .top-info{
    display:flex; justify-content:space-between; margin-top:12px;
    color:#fff; font-size:16px;
    text-shadow:0 0 10px rgba(0,255,232,0.6), 2px 2px 6px rgba(0,0,0,0.8);
  }

  /* 레벨 업 */
  #levelUpMenu{
    background:linear-gradient(135deg, rgba(0,30,27,0.95), rgba(0,60,55,0.9));
    border:4px solid var(--brand-bright);
    padding:30px;
    border-radius:20px;
    width:min(92vw, 900px);
    max-width:900px;
    color:#fff;
    box-shadow:0 20px 60px rgba(0,0,0,.5), 0 0 40px rgba(0,212,196,0.3);
    backdrop-filter:blur(10px);
  }
  #upgradeContainer{
    display:flex; gap:25px; justify-content:center; flex-wrap:wrap; margin-top:25px;
  }
  .upgrade-card{
    background:linear-gradient(135deg, rgba(0,100,95,0.3), rgba(0,60,55,0.5));
    border:3px solid rgba(0,212,196,0.4);
    width:220px; padding:20px;
    cursor:pointer;
    transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
    display:flex; flex-direction:column; align-items:center;
    border-radius:15px;
    position:relative;
    backdrop-filter:blur(5px);
    box-shadow:0 4px 15px rgba(0,0,0,0.3);
  }
  .upgrade-card::before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:15px;
    padding:3px;
    background:linear-gradient(135deg, var(--brand-bright), var(--brand), transparent);
    -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite:xor;
    mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite:exclude;
    opacity:0;
    transition:opacity .3s;
  }
  .upgrade-card:hover::before{
    opacity:1;
  }
  .upgrade-card:hover{
    transform:translateY(-8px) scale(1.05);
    border-color:var(--brand-bright);
    box-shadow:0 8px 30px rgba(0,212,196,.6), 0 0 40px rgba(0,255,232,0.4);
    background:linear-gradient(135deg, rgba(0,120,115,0.4), rgba(0,80,75,0.6));
  }
  .upgrade-icon{
    width:70px; height:70px; margin-bottom:15px;
    background:linear-gradient(135deg, rgba(0,212,196,0.2), rgba(0,169,156,0.3));
    display:flex; justify-content:center; align-items:center;
    border:3px solid var(--brand);
    border-radius:50%;
    box-shadow:0 4px 15px rgba(0,212,196,0.4), inset 0 2px 10px rgba(0,0,0,0.3);
    transition:all .3s;
  }
  .upgrade-card:hover .upgrade-icon{
    box-shadow:0 6px 25px rgba(0,255,232,0.6), inset 0 2px 10px rgba(255,255,255,0.1);
    transform:scale(1.1) rotateY(10deg);
  }
  .upgrade-title{
    color:var(--brand-bright);
    font-size:12px;
    margin-bottom:8px;
    text-shadow:0 0 10px rgba(0,255,232,0.6);
  }
  .upgrade-type{
    color:#a8e6cf;
    font-size:8px;
    margin-bottom:12px;
    text-shadow:0 0 5px rgba(168,230,207,0.5);
  }
  .upgrade-desc{
    color:#cef3ed;
    font-size:10px;
    line-height:1.5;
    text-align:center;
  }
  .new-tag{
    background:linear-gradient(135deg, #ff6b9d, #c44569);
    color:#fff;
    padding:4px 8px;
    font-size:8px;
    position:absolute;
    top:10px; right:10px;
    border-radius:8px;
    box-shadow:0 2px 10px rgba(255,107,157,0.5);
    animation:pulse 2s ease-in-out infinite;
  }
  @keyframes pulse{
    0%, 100%{transform:scale(1)}
    50%{transform:scale(1.1)}
  }

  /* 조이스틱 */
  #joystick-base{
    position:fixed; width:min(25vw,140px); height:min(25vw,140px); border-radius:50%;
    background:linear-gradient(135deg, rgba(0,100,95,0.4), rgba(0,60,55,0.5));
    border:4px solid rgba(0,212,196,0.6);
    box-shadow:0 0 30px rgba(0,212,196,.5), inset 0 0 30px rgba(0,0,0,.3);
    touch-action:none; display:none; z-index:20; opacity:0;
    transition:opacity .3s ease-out;
    pointer-events:none;
    backdrop-filter:blur(5px);
  }
  #joystick-base.active{
    opacity:1;
    animation:joystickAppear 0.3s ease-out;
  }
  @keyframes joystickAppear{
    from{transform:scale(0.8); opacity:0}
    to{transform:scale(1); opacity:1}
  }
  #joystick-thumb{
    position:absolute; width:45%; height:45%; top:27.5%; left:27.5%; border-radius:50%;
    background:linear-gradient(135deg, var(--brand-bright), var(--brand));
    transform:translate(0,0);
    transition:transform .1s ease-out;
    box-shadow:0 0 20px rgba(0,255,232,.8), inset 0 3px 10px rgba(255,255,255,.3);
    border:3px solid rgba(255,255,255,.6);
  }

  /* 시작 화면(반응형) */
  #startScreen{padding:40px 20px}
  /* #startScreen .screen-logo{
    position:absolute; bottom:40px; left:50%; transform:translateX(-50%);
    max-width:200px; width:50%;
  } */
  #startScreen .start-content{text-align:center}
  #startScreen h1{font-size:clamp(28px,7vw,48px); white-space:normal; word-break:keep-all; text-align:center;}
  #startScreen p{font-size:clamp(12px,3.5vw,14px); line-height:1.6}

  .screen-logo {
    position: absolute;
    bottom: calc(40px + var(--footer-banner-offset));
    left: 50%;
    transform: translateX(-50%);
    max-width: 200px;
    width: 50%;
  }

  @media (max-width:768px){
    h1{font-size:8vw}
    p{font-size:clamp(12px,3.5vw,14px); line-height:1.6}
    #victoryScreen h1,#gameOverScreen h1{font-size:clamp(28px,8vw,48px)}
  }

  @media (max-width:600px){
    #levelUpMenu{
      padding:22px 16px;
    }
    #upgradeContainer{
      flex-direction:column;
      align-items:stretch;
      gap:16px;
    }
    .upgrade-card{
      width:100%;
      padding:16px;
    }
  }

  @media (max-height:780px){
    #levelUpMenu{
      transform:scale(0.92);
      transform-origin:center center;
    }
  }
  @media (max-height:700px){
    #levelUpMenu{
      transform:scale(0.86);
    }
  }
  @media (max-height:620px){
    #levelUpMenu{
      transform:scale(0.8);
    }
  }
</style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <!-- 모바일 조이스틱 -->
  <div id="joystick-base"><div id="joystick-thumb"></div></div>

  <!-- HUD 영역 -->
  <div id="hud">
    <div class="xp-container">
      <div id="xpBar"></div>
      <div id="levelText">LV 1</div>
    </div>
    <div class="top-info">
      <div id="timer">00:00</div>
      <div id="killCount">✨ 0</div>
    </div>
  </div>

  <!-- 시작 -->
  <div id="startScreen" class="overlay">
    <div class="start-content">
      <h1>DREAM SURVIVORS</h1>
      <p>드림과 함께 꿈 속의 악몽들을 헤쳐나가세요!</p>
      <p>이동: PC는 방향키 / 모바일은 조이스틱 / 공격은 자동입니다.</p>
      <p style="font-size:10px; color:#003d38; opacity:0.5; margin-top:8px;">
        ※ 본 게임은 <em>Vampire Survivors</em>를 레퍼런스로 제작되었습니다.
      </p>
      <button id="btnStart">꿈 속으로</button>
    </div>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 일시정지 -->
  <div id="pauseMenu" class="overlay hidden">
    <h2>잠깐의 휴식</h2>
    <div id="statsContainer" style="text-align:left;margin-bottom:20px;font-size:10px"></div>
    <button id="btnResume">계속하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 게임 오버 -->
  <div id="gameOverScreen" class="overlay hidden">
    <h1 id="goTitle" style="color:#b30000">꿈속에 갇혔습니다...</h1>
    <h2 id="goTime">버틴 시간: 00:00</h2>
    <p id="goKills">물리친 악몽: 0</p>
    <p id="goLevel">성장 레벨: 1</p>
    <button id="btnRestart">다시 도전하기</button>
    <button id="btnPolicyGO" data-policy-link="https://ugc.production.linktr.ee/006818f7-8118-4032-b477-91dae7b65f6f_-DREAM--SNS-compressed.pdf?fbclid=PAdGRleAN03XVleHRuA2FlbQIxMQABp1wlGDKDiaCqJJTCHnIWNpviJ-VywFu3vw0e589pS3-ApI7wzP9mhDWc8i1m_aem_iq6sykSxuGy9HOrdv0dQPg">정책 확인하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 승리 -->
  <div id="victoryScreen" class="overlay hidden">
    <h1 style="color:var(--brand)">꿈속에서 깨어났습니다!</h1>
    <p>우리의 꿈이 현실이 되었습니다.</p>
    <p id="vKills">물리친 악몽: 0</p>
    <p style="font-size:12px;">“함께 꿈꾸는 캠퍼스, 드림이 만듭니다.”</p>
    <button id="btnRestartVic">다시하기</button>
    <button id="btnPolicyVic" data-policy-link="https://ugc.production.linktr.ee/006818f7-8118-4032-b477-91dae7b65f6f_-DREAM--SNS-compressed.pdf?fbclid=PAdGRleAN03XVleHRuA2FlbQIxMQABp1wlGDKDiaCqJJTCHnIWNpviJ-VywFu3vw0e589pS3-ApI7wzP9mhDWc8i1m_aem_iq6sykSxuGy9HOrdv0dQPg">정책 확인하기</button>
    <img src="logo.png" alt="DREAM Logo" class="screen-logo" />
  </div>

  <!-- 레벨 업 -->
  <div id="levelUpScreen" class="overlay hidden">
    <div id="levelUpMenu">
      <h2 style="color:#8e44ad;margin:0">성장!</h2>
      <p style="margin-bottom:0">새로운 꿈의 조각을 선택하세요</p>
      <div id="upgradeContainer"></div>
    </div>
  </div>

  <div id="footerBanner">제주대학교 58대 DREAM 총학생회 선거운동본부</div>

<script>
/* =========================================================
   드림 서바이버즈 — 엔진과 게임 로직 (리팩터링)
   - 기능/연출 동일, 구조/가독성 개선
========================================================= */

/* ---------- 설정 및 전역 ---------- */
const C = {
  WIDTH: innerWidth,
  HEIGHT: innerHeight,
  FPS: 60,
  TILE_SIZE: 128,
  COLORS: {
    bg:'#e6f5f2', grid:'#fff7e0', player:'#00a99c', hp:'#00a99c', hpBg:'#98d2c6',
    e1:'#ffc1e3', e2:'#ffb3ba', e3:'#ffffba', e4:'#d1b3ff', e5:'#008080',
    xp1:'#ffd700', xp2:'#ffec8b', xp3:'#ffffff', dmgWhite:'#ffffff', dmgCrit:'#ff85a2'
  }
};

/* ✅ 최적화: 중앙 게임 상태에 런타임 캐시 추가 */
const GS = {
  canvas: document.getElementById('gameCanvas'),
  ctx: document.getElementById('gameCanvas').getContext('2d',{alpha:false}),
  state:'start',
  player:null,
  enemies:[], projectiles:[], enemyProjectiles:[],
  gems:[], potions:[], particles:[], particlePool:[], damageTexts:[],
  camera:{x:0,y:0}, input:{up:false,down:false,left:false,right:false},
  audio:null, time:0, kills:0, frameCount:0, lastTime:0, dt:0,
  smoothedDt:0,
  screenShake:0, spawnTimer:0, bossAlert:{text:'',life:0},
  victoryInProgress:false, stageIndex:0, stageTitle:null,
  bossHasSpawned:false, level5BossTriggered:false, level10BossTriggered:false,
  level15BossTriggered:false, level20BossTriggered:false,
  currentEnemyNames:null, currentBg:null, startTime:null, gameOver:false,
  _stageTransitioning:false,
  gradientCache:null,
  loopActive:false
};

GS.playerImg = new Image();
GS.playerImgReady = false;
GS.playerImg.src = 'DR.png';
GS.playerImg.onload = () => { GS.playerImgReady = true; };

/* ✅ 최적화: 기기 프로필이 예산을 조정하면서 비주얼 유지 */
const DEVICE = (() => {
  const nav = navigator || {};
  const coarse = (matchMedia && matchMedia('(pointer:coarse)').matches) ||
                 'ontouchstart' in window ||
                 (nav.maxTouchPoints || 0) > 0 ||
                 innerWidth <= 820;
  // ✅ 기본 픽셀 밀도와 비주얼 품질 유지, 로직 부하만 줄이기
  return {
    isMobile: coarse,
    pixelRatio: Math.min(window.devicePixelRatio || 1, 2), // 모바일에서는 최대 2로 제한
    enemyCap: coarse ? 80 : 280,
    particleCap: coarse ? 100 : 360,
    cullX: coarse ? 500 : 900,
    cullY: coarse ? 400 : 600
  };
})();

// ✅ 적응형 성능 스케일링 시스템
const PERF = {};
PERF.score = (() => {
  let score = 1;
  if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 6) score *= 0.8;
  if (navigator.deviceMemory && navigator.deviceMemory < 4) score *= 0.7;
  if (/Mali|Adreno|PowerVR/i.test(navigator.userAgent)) score *= 0.8;
  return Math.max(score, 0.5);
})();

const HUD = {
  xpBar: document.getElementById('xpBar'),
  levelText: document.getElementById('levelText'),
  timer: document.getElementById('timer'),
  killCount: document.getElementById('killCount')
};

/* ---------- 리사이즈 ---------- */
function resize() {
  // 고성능 모니터(특히 고 DPI)에서 성능 유지를 위해 devicePixelRatio 제한
  const ratio = DEVICE.pixelRatio;
  C.WIDTH = Math.floor(innerWidth);
  C.HEIGHT = Math.floor(innerHeight);
  GS.canvas.width = Math.floor(C.WIDTH * ratio);
  GS.canvas.height = Math.floor(C.HEIGHT * ratio);
  GS.canvas.style.width = `${C.WIDTH}px`;
  GS.canvas.style.height = `${C.HEIGHT}px`;
  GS.ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  GS.ctx.imageSmoothingEnabled = false;
  GS.ctx.mozImageSmoothingEnabled = false;
  GS.ctx.webkitImageSmoothingEnabled = false;
  GS.gradientCache=null;
  // ✅ GPU 합성과 하드웨어 가속 힌트 사용
  // 모바일은 medium, 데스크톱은 high로 스무딩 설정
  GS.ctx.imageSmoothingEnabled = true;
  if (DEVICE.isMobile) {
    GS.ctx.imageSmoothingQuality = "medium";
  } else {
    GS.ctx.imageSmoothingQuality = "high";
  }
  GS.canvas.style.willChange = "transform, opacity";
  GS.canvas.style.transform = "translateZ(0)";
  GS.canvas.style.imageRendering = "auto";
  // ✅ 모바일 합성을 부드럽게 하는 GPU CSS 힌트 추가
  GS.canvas.style.backfaceVisibility = "hidden";
  GS.canvas.style.contain = "layout style paint";
  // CPU 배칭: 정적 배경 버퍼 생성/재생성
  GS.bgBuffer = null;
}
let resizeTimer;
addEventListener('resize', ()=> {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 200);
});
resize();

/* ---------- 수학 유틸 ---------- */
const M = {
  dist:(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1),
  distSq:(x1,y1,x2,y2)=> (x2-x1)**2 + (y2-y1)**2,
  angle:(x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1),
  rand:(min,max)=>Math.random()*(max-min)+min,
  randInt:(min,max)=>Math.floor(Math.random()*(max-min+1))+min,
  clamp:(v,min,max)=>Math.min(Math.max(v,min),max),
  lerp:(a,b,t)=>a+(b-a)*t,
  collides:(a,b)=> M.distSq(a.x,a.y,b.x,b.y) < (a.r+b.r)**2,
  formatTime:(s)=> {
    const m = Math.floor(s/60), sec = Math.floor(s%60);
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
};

/* ---------- 오디오 ---------- */
class AudioSys{
  constructor(){ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); this.masterVol=.3; }
  playTone(freq,type,dur,vol=1,slide=0){
    if(GS.state==='paused') return;
    const {ctx} = this; const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type=type; osc.frequency.setValueAtTime(freq, ctx.currentTime);
    if(slide!==0) osc.frequency.exponentialRampToValueAtTime(freq+slide, ctx.currentTime+dur);
    g.gain.setValueAtTime(vol*this.masterVol, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime+dur);
    osc.connect(g); g.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+dur);
  }
  sfxShoot(){this.playTone(M.rand(600,800),'sine',.1,.2,200)}
  sfxEnemyShoot(){this.playTone(M.rand(300,400),'square',.1,.1)}
  sfxHit(){this.playTone(M.rand(200,300),'triangle',.1,.3)}
  sfxXp(){this.playTone(M.rand(1000,1200),'sine',.08,.15)}
  sfxLevelUp(){
    const now = this.ctx.currentTime;
    [523,659,783,1046].forEach((f,i)=>{
      const o=this.ctx.createOscillator(), g=this.ctx.createGain();
      o.type='triangle'; o.frequency.value=f;
      g.gain.setValueAtTime(.2, now+i*.1);
      g.gain.linearRampToValueAtTime(0, now+i*.1+.2);
      o.connect(g); g.connect(this.ctx.destination);
      o.start(now+i*.1); o.stop(now+i*.1+.2);
    });
  }
  sfxHurt(){this.playTone(150,'sawtooth',.3,.5,-50)}
  sfxDie(){this.playTone(100,'sawtooth',1.5,.6,-80)}
}

/* ---------- 그리기 헬퍼 ---------- */
const Draw = {
  glow:(color='rgba(0,0,0,0.6)', blur=20, alpha=0.8)=>{
    if (GS.lowPerfMode || DEVICE.isMobile) return;
    const ctx=GS.ctx;
    ctx.save();
    ctx.shadowBlur = blur;
    ctx.shadowColor=color;
    ctx.globalAlpha=alpha;
  },
  resetGlow:()=>{ const ctx=GS.ctx; ctx.restore(); },
  circle(x,y,r,fill,stroke=null,lw=2){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    if (cx<-r||cx>C.WIDTH+r||cy<-r||cy>C.HEIGHT+r) return;
    const ctx=GS.ctx; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fillStyle=fill; ctx.fill();
    if(stroke){ctx.strokeStyle=stroke; ctx.lineWidth=lw; ctx.stroke();}
  },
  rect(x,y,w,h,color,angle=0){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    const ctx=GS.ctx; ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
    ctx.fillStyle=color; ctx.fillRect(-w/2,-h/2,w,h); ctx.restore();
  },
  text(str,x,y,size,color,align='center'){
    const cx = x-GS.camera.x + C.WIDTH/2;
    const cy = y-GS.camera.y + C.HEIGHT/2;
    const ctx=GS.ctx; ctx.font = `${size}px 'Press Start 2P'`;
    ctx.fillStyle=color; ctx.textAlign=align; ctx.fillText(str,cx,cy);
  },
  background(padding=0){
    if(!GS.gradientCache){
      const ctx=GS.ctx;
      const [c1,c2]=GS.currentBg||['#e6f5f2','#d4ebe7'];
      const g=ctx.createLinearGradient(0,0,C.WIDTH,C.HEIGHT);
      g.addColorStop(0,c1); g.addColorStop(1,c2);
      GS.gradientCache=g;
      applyStageBackgroundColors([c1,c2]);
    }
    const ctx=GS.ctx;
    const pad=Math.ceil(padding);
    ctx.fillStyle=GS.gradientCache;
    ctx.fillRect(-pad,-pad,C.WIDTH+pad*2,C.HEIGHT+pad*2);
  }
};

/* ---------- 기본 엔티티 ---------- */
class Entity{ constructor(x,y,r){ this.x=x; this.y=y; this.r=r; this.active=true; } }

/* ---------- 이펙트 ---------- */
class Particle extends Entity{
  constructor(x,y,color,size,speed,life){ super(x,y,0); this.reset(x,y,color,size,speed,life); }
  reset(x,y,color,size,speed,life){
    this.x=x; this.y=y; this.color=color; this.size=size; this.life=life; this.maxLife=life;
    const a=M.rand(0,Math.PI*2); this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed; this.active=true; return this;
  }
  update(){ this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.life-=GS.dt; if(this.life<=0){this.active=false; GS.particlePool.push(this);} }
  draw(){ const a=this.life/this.maxLife; GS.ctx.globalAlpha=a; Draw.circle(this.x,this.y,this.size,this.color); GS.ctx.globalAlpha=1; }
}
class DamageText extends Entity{
  constructor(x,y,dmg,isCrit){ super(x+M.rand(-10,10),y-20,0); this.text=Math.round(dmg); this.color=isCrit?C.COLORS.dmgCrit:C.COLORS.dmgWhite; this.size=isCrit?20:12; this.life=1; this.vy=-50; }
  update(){ this.y+=this.vy*GS.dt; this.life-=GS.dt; if(this.life<=0)this.active=false; }
  draw(){ GS.ctx.globalAlpha=Math.min(1,this.life*2); Draw.text(this.text,this.x,this.y,this.size,this.color); GS.ctx.globalAlpha=1; }
}
/* ✅ 최적화: 기기별 파티클 제한을 준수하는 풀 */
function spawnParticles(x,y,color,count,hw=false){
  const pool=GS.particlePool;
  const limit=Math.min(count, DEVICE.particleCap);
  for(let i=0;i<limit;i++){
    // ✅ 저사양 기기에서는 파티클 생성을 간헐적으로 생략
    if (Math.random() > PERF.score) return;
    const speed = hw? M.rand(50,150): M.rand(100,300);
    const size = hw? M.rand(2,5): M.rand(1,3);
    const life = M.rand(.2,.5);
    const particle = pool.length>0 ? pool.pop().reset(x,y,color,size,speed,life) : new Particle(x,y,color,size,speed,life);
    GS.particles.push(particle);
  }
}
/* ✅ 최적화: 업데이트 중 비활성 객체를 제자리 압축으로 제거 */
function stepEntities(list){
  let write=0;
  for(let i=0;i<list.length;i++){
    const item=list[i];
    item.update();
    if(item.active) list[write++]=item;
  }
  list.length=write;
}

/* ---------- 수집 아이템 ---------- */
class ExperienceOrb extends Entity{
  constructor(x,y,value){
    super(x,y,6); this.value=value;
    if(value<5){ this.color=C.COLORS.xp1; this.r=5; }
    else if(value<20){ this.color=C.COLORS.xp2; this.r=7; }
    else{ this.color=C.COLORS.xp3; this.r=9; }
    this.vx=0; this.vy=0; this.magnetized=false;
  }
  update(){
    const d2 = M.distSq(this.x,this.y,GS.player.x,GS.player.y);
    if(this.magnetized||d2<GS.player.stats.magnet**2){
      this.magnetized=true;
      const a = M.angle(this.x,this.y,GS.player.x,GS.player.y);
      const speed=600; this.vx=M.lerp(this.vx,Math.cos(a)*speed,5*GS.dt);
      this.vy=M.lerp(this.vy,Math.sin(a)*speed,5*GS.dt);
      this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt;
      if(d2<(GS.player.r+this.r)**2){ GS.player.gainXp(this.value); this.active=false; if(GS.audio) GS.audio.sfxXp(); }
    }else{ this.y+=Math.sin(GS.time*5+this.x)*10*GS.dt; }
  }
  draw(){
    const cx = this.x-GS.camera.x + C.WIDTH/2;
    const cy = this.y-GS.camera.y + C.HEIGHT/2;
    if (cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const ctx=GS.ctx; ctx.save(); ctx.translate(cx,cy); ctx.rotate(GS.time);
    ctx.beginPath(); ctx.moveTo(0,-this.r);
    for(let i=0;i<5;i++){ ctx.rotate(Math.PI/5); ctx.lineTo(0,-(this.r*.5)); ctx.rotate(Math.PI/5); ctx.lineTo(0,-this.r); }
    ctx.closePath(); ctx.fillStyle=this.color; ctx.fill(); ctx.restore();
  }
}
class HealthPotion extends Entity{
  constructor(x,y){ super(x,y,10); this.color='#ff6b6b'; this.healAmount = GS.player.stats.maxHp*0.20; }
  update(){
    if(M.collides(this,GS.player)){
      GS.player.hp = Math.min(GS.player.stats.maxHp, GS.player.hp + this.healAmount);
      this.active=false; if(GS.audio) GS.audio.playTone(800,'sine',.2,.4);
    }
  }
  draw(){
    const cx = this.x-GS.camera.x + C.WIDTH/2;
    const cy = this.y-GS.camera.y + C.HEIGHT/2;
    if (cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const r=this.r, ctx=GS.ctx; ctx.fillStyle=this.color; ctx.beginPath();
    ctx.moveTo(cx, cy + r/4);
    ctx.quadraticCurveTo(cx, cy, cx - r/4, cy);
    ctx.quadraticCurveTo(cx - r/2, cy, cx - r/2, cy + r/4);
    ctx.quadraticCurveTo(cx - r/2, cy + r/2, cx, cy + r);
    ctx.quadraticCurveTo(cx + r/2, cy + r/2, cx + r/2, cy + r/4);
    ctx.quadraticCurveTo(cx + r/2, cy, cx + r/4, cy);
    ctx.quadraticCurveTo(cx, cy, cx, cy + r/4);
    ctx.fill();
  }
}

/* ---------- 발사체 ---------- */
class Projectile extends Entity{
  constructor(x,y,r,vx,vy,damage,pierce,duration,color,kb){
    super(x,y,r);
    Object.assign(this,{vx,vy,damage,pierce,duration,color,kb});
    this.hitList=[];
  }
  update(){ 
    this.x+=this.vx*GS.dt; 
    this.y+=this.vy*GS.dt; 
    this.duration-=GS.dt; 
    if(this.duration<=0) this.active=false; 
    this.hitList=[];
  }
  draw(){
    const cx=this.x-GS.camera.x+C.WIDTH/2;
    const cy=this.y-GS.camera.y+C.HEIGHT/2;
    if(cx<-this.r||cx>C.WIDTH+this.r||cy<-this.r||cy>C.HEIGHT+this.r) return;
    const ctx=GS.ctx;

    // 무기 종류에 따라 다른 모양으로 그림
    if(this.color==='#87CEFA'){
      // 마법봉 : 별 모양 탄환
      Draw.glow(this.color,14,0.95);
      const spikes=5, outer=this.r, inner=this.r*0.45;
      ctx.beginPath();
      for(let i=0;i<spikes;i++){
        const a=(i*Math.PI*2/spikes)+(GS.time*6);
        const ax=cx+Math.cos(a)*outer;
        const ay=cy+Math.sin(a)*outer;
        ctx.lineTo(ax,ay);
        const b=a+Math.PI/spikes;
        const bx=cx+Math.cos(b)*inner;
        const by=cy+Math.sin(b)*inner;
        ctx.lineTo(bx,by);
      }
      ctx.closePath();
      ctx.fillStyle=this.color;
      ctx.fill();
      Draw.resetGlow();
      ctx.beginPath(); ctx.arc(cx,cy,Math.max(1,this.r*0.35),0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    } else if(this.color==='#44ffaa'){
      // 부메랑류 : 타원형 회전 탄환
      Draw.glow(this.color,18,0.9);
      ctx.beginPath();
      ctx.ellipse(cx,cy,this.r*1.6,this.r*0.9,Math.atan2(this.vy,this.vx),0,Math.PI*2);
      ctx.fillStyle=this.color; ctx.fill();
      Draw.resetGlow();
    } else {
      // 기본 : 긴 타원형 파편 형태
      Draw.glow(this.color,12,0.9);
      const angle=Math.atan2(this.vy,this.vx);
      const w=Math.max(1,this.r*1.6);
      const h=Math.max(1,this.r);
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-w/2+h/2,-h/2);
      ctx.arcTo(w/2-h/2,-h/2,w/2-h/2,h/2,h/2);
      ctx.arcTo(w/2-h/2,h/2,-w/2+h/2,h/2,h/2);
      ctx.closePath();
      ctx.fillStyle=this.color;
      ctx.fill();
      ctx.beginPath(); ctx.globalAlpha=0.8;
      ctx.arc(0,0,Math.max(0.5,this.r*0.45),0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fill();
      ctx.globalAlpha=1.0;
      ctx.restore();
      Draw.resetGlow();
    }
  }
  onHit(enemy){
    const isCrit=Math.random()<GS.player.stats.critChance;
    const dmg=this.damage*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
    enemy.takeDamage(dmg,isCrit,this.kb,Math.atan2(this.vy,this.vx));
    this.pierce--; if(this.pierce<0) this.active=false;
    if(GS.audio) GS.audio.sfxHit();
  }
}
class EnemyProjectile extends Entity{
  constructor(x,y,r,vx,vy,damage,duration,color){ super(x,y,r); Object.assign(this,{vx,vy,damage,duration,color}); }
  update(){
    this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.duration-=GS.dt;
    if(this.duration<=0) this.active=false;
    if(M.collides(this,GS.player)){ GS.player.takeDamage(this.damage); this.active=false; }
  }
  draw(){ Draw.glow(this.color,15); Draw.circle(this.x,this.y,this.r,this.color,'#000',2); Draw.resetGlow(); }
}
class BoomerangProj extends Projectile{
  constructor(p){ super(p.x,p.y,p.r,p.vx,p.vy,p.dmg,999,p.dur,'#44ffaa',p.kb); this.speed=Math.hypot(this.vx,this.vy); this.angle=Math.atan2(this.vy,this.vx); this.timer=0; this.returnTime=p.dur/2; }
  update(){
    this.timer+=GS.dt; const currentSpeed = this.speed*(1-(this.timer/this.returnTime));
    this.x+=Math.cos(this.angle)*currentSpeed*GS.dt; this.y+=Math.sin(this.angle)*currentSpeed*GS.dt;
    this.duration-=GS.dt;
    if(this.duration<=0 || (this.timer>this.returnTime && M.distSq(this.x,this.y,GS.player.x,GS.player.y)<1600)) this.active=false;
    this.hitList=[];
  }
  draw(){
    Draw.glow(this.color,18,0.9);
    Draw.rect(this.x,this.y,this.r*2.5,this.r,this.color,this.timer*15);
    Draw.resetGlow();
  }
}

/* ---------- 무기 ---------- */
class Weapon{
  constructor(name,iconColor){
    Object.assign(this,{name,iconColor});
    this.level=0; this.maxLevel=8; this.cooldown=0;
    this.baseDmg=10; this.baseCd=1.5; this.baseSpd=400; this.baseDur=2; this.baseArea=1; this.baseAmount=1; this.basePierce=0; this.kb=100;
  }
  get stats(){
    const ps=GS.player.stats;
    return {
      dmg:this.baseDmg*(1+this.level*.2),
      cd:this.baseCd*(1-this.level*.05)*ps.cooldown,
      spd:this.baseSpd*(1+this.level*.1)*ps.speedProj,
      dur:this.baseDur*(1+this.level*.1)*ps.duration,
      area:this.baseArea*(1+this.level*.15)*ps.area,
      amount:this.baseAmount+Math.floor(this.level/2)+ps.amount,
      pierce:this.basePierce+Math.floor(this.level/3),
      kb:this.kb
    };
  }
  update(){ this.cooldown-=GS.dt; if(this.cooldown<=0){ this.attack(); this.cooldown=this.stats.cd; } }
  getNearestEnemy(){
    let nearest=null, min=Infinity;
    for(const e of GS.enemies){ const d=M.distSq(GS.player.x,GS.player.y,e.x,e.y); if(d<C.WIDTH**2 && d<min){ min=d; nearest=e; } }
    return nearest;
  }
  attack(){} getDescription(){ return "Increases stats." }
}
class Wand extends Weapon{
  constructor(){ super("의견 전달","#66ccff"); this.baseDmg=10; this.baseCd=1.0; this.baseSpd=500; this.kb=150; this.cooldownTimer = 0; }
  attack(){
    const target=this.getNearestEnemy(); if(!target){ this.cooldown=.1; return; }
    const s=this.stats; if(GS.audio) GS.audio.sfxShoot();
    if(!this.cooldownTimer) this.cooldownTimer = 0;
    this.cooldownTimer = 0;
    this._wandAttackIndex = 0;
    this._wandAttackAmount = s.amount;
    this._wandAttackTarget = target;
  }
  update(){
    this.cooldown-=GS.dt;
    if(this.cooldown<=0){
      this.attack();
      this.cooldown=this.stats.cd;
    }

    if(this._wandAttackAmount > 0){
      if(!this._wandAttackDelay) this._wandAttackDelay = 0;
      this._wandAttackDelay -= GS.dt*1000;
      if(this._wandAttackDelay <= 0){
        if(GS.state!=='running'){ this._wandAttackAmount = 0; return; }
        const t=this.getNearestEnemy() || this._wandAttackTarget;
        const s=this.stats;
        const a=M.angle(GS.player.x,GS.player.y,t.x,t.y) + M.rand(-.1,.1);
        GS.projectiles.push(new Projectile(GS.player.x,GS.player.y,8*s.area,Math.cos(a)*s.spd,Math.sin(a)*s.spd,s.dmg,s.pierce,s.dur,'#87CEFA',s.kb));
        this._wandAttackAmount--;
        this._wandAttackDelay = 100;
      }
    }
  }
  getDescription(){ return "가장 가까운 적에게 마법 발사체를 발사합니다."; }
}
class OrbitingBlade extends Weapon{
  constructor(){ super("연대의 고리","#ffcc00"); this.baseDmg=15; this.baseCd=3.0; this.baseDur=2.5; this.baseArea=1; this.kb=200; this.activeBlades=[]; this.rotOffset=0; }
  update(){
    super.update(); this.rotOffset+=GS.dt*3; const s=this.stats; const radius=120*s.area;
    this.activeBlades=this.activeBlades.filter(b=>b.life>0);
    this.activeBlades.forEach((b,i)=>{
      b.life-=GS.dt;
      const ang=this.rotOffset + (Math.PI*2/this.activeBlades.length)*i;
      b.x=GS.player.x+Math.cos(ang)*radius; b.y=GS.player.y+Math.sin(ang)*radius; b.hitTimer-=GS.dt;
      if(b.hitTimer<=0){
        for(const e of GS.enemies){
          if(M.collides(b,e)){
            const isCrit=Math.random()<GS.player.stats.critChance;
            const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
            e.takeDamage(dmg,isCrit,s.kb,ang);
            if(GS.audio) GS.audio.sfxHit();
          }
        }
        b.hitTimer=.2;
      }
    });
  }
  attack(){ const s=this.stats; this.activeBlades=[]; for(let i=0;i<s.amount;i++) this.activeBlades.push({x:0,y:0,r:15*s.area,life:s.dur,hitTimer:0}); if(GS.audio) GS.audio.playTone(600,'sine',.5,.1); }
  draw(){
    this.activeBlades.forEach(b=>{
      const cx=b.x-GS.camera.x+C.WIDTH/2, cy=b.y-GS.camera.y+C.HEIGHT/2, r=b.r, ctx=GS.ctx;
      ctx.save(); ctx.translate(cx,cy); ctx.rotate(this.rotOffset*2);
      ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,Math.PI/2,false);
      ctx.quadraticCurveTo(r*.5,0,0,-r); ctx.closePath();
      Draw.glow('#ffcc00',20); ctx.fillStyle='#ffcc00'; ctx.fill(); Draw.resetGlow(); ctx.restore();
    });
  }
  getDescription(){ return "플레이어 주위를 회전하며 닿는 모든 적에게 피해를 주는 고리를 소환합니다."; }
}
class Axe extends Weapon{
  constructor(){ super("결단의 망치","#cc4444"); this.baseDmg=40; this.baseCd=2.0; this.baseSpd=500; this.basePierce=99; this.baseArea=1.5; this.kb=400; }
  attack(){
    const s=this.stats; if(GS.audio) GS.audio.playTone(200,'square',.2,.2,-50);
    for(let i=0;i<s.amount;i++){
      const spread=(s.amount>1)? M.lerp(-.5,.5, i/(s.amount-1)): 0;
      const p=new Projectile(GS.player.x,GS.player.y-20,15*s.area,Math.sin(spread)*200,-s.spd,s.dmg,s.pierce,3,'#ff85a2',s.kb);
      p.t=0; p.ro=M.rand(0,Math.PI*2);
      p.update=function(){ this.t+=GS.dt; this.vy+=800*GS.dt; this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt; this.ro+=GS.dt*10; this.duration-=GS.dt; if(this.y>GS.player.y+C.HEIGHT/2) this.active=false; this.hitList=[]; };
      p.draw=function(){
  const ctx=GS.ctx;
  const cx=this.x-GS.camera.x+C.WIDTH/2;
  const cy=this.y-GS.camera.y+C.HEIGHT/2;
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(this.ro);
  Draw.glow(this.color,18);

  ctx.fillStyle=this.color;
  ctx.fillRect(-this.r*0.8,-this.r*0.3,this.r*1.2,this.r*0.6);

  ctx.fillStyle='#8b5a2b';
  ctx.fillRect(-this.r*0.1,-this.r*1.5,this.r*0.2,this.r*1.8);

  Draw.resetGlow();
  ctx.restore();
};
      GS.projectiles.push(p);
    }
  }
  getDescription(){ return "위쪽으로 포물선을 그리며 날아가 다수의 적을 관통하는 도끼를 던집니다."; }
}
class Beam extends Weapon{
  constructor(){ super("비전의 빛","#ff66ff"); this.baseDmg=8; this.baseCd=4.0; this.baseDur=1.5; this.kb=10; this.firing=false; this.fireTimer=0; this.targetAngle=0; }
  update(){
    super.update();
    if(this.firing){
      this.fireTimer-=GS.dt;
      if(this.fireTimer%0.2<GS.dt){
        const s=this.stats;
        const isCrit=Math.random()<GS.player.stats.critChance;
        const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
        const ex=GS.player.x+Math.cos(this.targetAngle)*C.WIDTH;
        const ey=GS.player.y+Math.sin(this.targetAngle)*C.WIDTH;
        for(const e of GS.enemies){
          const dx=ex-GS.player.x, dy=ey-GS.player.y, lenSq=dx*dx+dy*dy;
          const t=((e.x-GS.player.x)*dx + (e.y-GS.player.y)*dy)/lenSq;
          if(t<0||t>1) continue;
          const cx=GS.player.x+t*dx, cy=GS.player.y+t*dy;
          const d=M.dist(e.x,e.y,cx,cy);
          if(d<e.r + (20*s.area)) e.takeDamage(dmg,isCrit,s.kb,this.targetAngle);
        }
        if(GS.audio) GS.audio.playTone(100,'sawtooth',.1,.05);
      }
      if(this.fireTimer<=0) this.firing=false;
    }
  }
  attack(){
    const t=this.getNearestEnemy(); this.targetAngle = t? M.angle(GS.player.x,GS.player.y,t.x,t.y) : M.rand(0,Math.PI*2);
    this.firing=true; this.fireTimer=this.stats.dur; if(GS.audio) GS.audio.playTone(800,'sawtooth',.5,.1,-400);
  }
  draw(){
    if(this.firing){
      const ctx=GS.ctx, w=C.WIDTH*1.5, h=30*this.stats.area*(.5+Math.random()*.5);
      ctx.save(); ctx.translate(C.WIDTH/2,C.HEIGHT/2); ctx.rotate(this.targetAngle);
      Draw.glow('#ff66ff',30); ctx.fillStyle='rgba(255,100,255,.5)'; ctx.fillRect(0,-h/2,w,h);
      ctx.fillStyle='#fff'; ctx.fillRect(0,-h/4,w,h/2); Draw.resetGlow(); ctx.restore();
    }
  }
  getDescription(){ return "가장 가까운 적 방향으로 모든 것을 관통하는 강력한 빔을 발사합니다."; }
}
class Boomerang extends Weapon{
  constructor(){ super("드림 배지","#44ffaa"); this.baseDmg=25; this.baseCd=2.5; this.baseSpd=700; this.baseDur=2.0; this.baseArea=1.2; this.kb=250; }
  attack(){
    const t=this.getNearestEnemy(); let a = t? M.angle(GS.player.x,GS.player.y,t.x,t.y) : M.rand(0,Math.PI*2);
    const s=this.stats; if(GS.audio) GS.audio.sfxShoot();
    for(let i=0;i<s.amount;i++){
      const ang = a + M.lerp(-.3,.3, i/(s.amount||1));
      GS.projectiles.push(new BoomerangProj({x:GS.player.x,y:GS.player.y,r:12*s.area,vx:Math.cos(ang)*s.spd,vy:Math.sin(ang)*s.spd,dmg:s.dmg,dur:s.dur,kb:s.kb}));
    }
  }
  getDescription(){ return "적을 꿰뚫고 플레이어에게 다시 돌아오는 부메랑을 던집니다."; }
}
class Aura extends Weapon{
  constructor(){ super("드림 오라","#ffffff"); this.baseDmg=5; this.baseCd=.5; this.baseArea=1.0; this.kb=50; this.pulse=0; }
  attack(){
    this.pulse=1; const s=this.stats, r=80*s.area;
    const isCrit=Math.random()<GS.player.stats.critChance;
    const dmg=s.dmg*GS.player.stats.might*(isCrit?GS.player.stats.critDmg:1);
    for(const e of GS.enemies){
      if(M.distSq(GS.player.x,GS.player.y,e.x,e.y)<(r+e.r)**2){
        if((e.auraTimer||0)<=0){ e.takeDamage(dmg,isCrit,s.kb, M.angle(GS.player.x,GS.player.y,e.x,e.y)); e.auraTimer=s.cd; }
      }
    }
  }
  draw(){
    if(this.level>0){
      const r=80*this.stats.area; this.pulse=Math.max(0,this.pulse-GS.dt*2);
      const ctx=GS.ctx, cx=C.WIDTH/2, cy=C.HEIGHT/2, g=ctx.createRadialGradient(cx,cy,r*.2,cx,cy,r);
      ctx.globalAlpha=.2+this.pulse*.4; g.addColorStop(0,'rgba(0,169,156,.5)'); g.addColorStop(1,'rgba(0,169,156,0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    }
  }
  getDescription(){ return "주변의 적에게 지속적으로 피해를 주는 오라를 생성합니다."; }
}

const WEAPON_POOL = [Wand, OrbitingBlade, Axe, Beam, Boomerang, Aura];
const PASSIVE_POOL = [
  { id:'might',  name:'학생 열정', desc:'모든 공격의 피해량이 10% 증가합니다.', apply:s=>s.might+=.1,     icon:'#f00' },
  { id:'speed',  name:'발로 뛰기', desc:'캐릭터의 이동 속도가 10% 증가합니다.', apply:s=>s.moveSpeed+=20,   icon:'#fff' },
  { id:'area',   name:'홍보물 제작력', desc:'무기 공격의 범위가 10% 증가합니다.', apply:s=>s.area+=.1,      icon:'#ff0' },
  { id:'cd',     name:'기획력 향상', desc:'모든 무기의 재사용 대기시간이 8% 감소합니다.', apply:s=>s.cooldown*=.92, icon:'#00f' },
  { id:'amount', name:'팀 시너지', desc:'추가 발사체를 1개 발사합니다.', apply:s=>s.amount+=1,           icon:'#0ff' },
  { id:'magnet', name:'소통력', desc:'경험치 구슬을 획득하는 범위가 30% 증가합니다.', apply:s=>s.magnet*=1.3, icon:'#a0a' },
  { id:'health', name:'드림의 결속', desc:'최대 체력이 20% 증가하고, 현재 체력을 일부 회복합니다.', apply:s=>{s.maxHp*=1.2; GS.player.hp+=GS.player.stats.maxHp*.2;}, icon:'#b33' },
  { id:'regen',  name:'휴식의 시간', desc:'초당 0.5의 체력을 회복합니다.', apply:s=>s.regen+=.5,          icon:'#f88' }
];

class Player extends Entity{
  constructor(){
    super(0,0,15);
    this.baseStats={maxHp:100, moveSpeed:200, magnet:100, might:1, area:1, speedProj:1, duration:1, amount:0, cooldown:1, luck:1, critChance:.05, critDmg:2.0, armor:3, regen:0};
    this.stats={...this.baseStats};
    this.hp=this.stats.maxHp; this.xp=0; this.level=1; this.nextLevelXp=5;
    this.weapons=[]; this.passives={}; this.invulnTimer=0; this.regenTimer=0; this.facing=1;
    this.addWeapon(new Wand());
  }
  update(){
    if(GS.victoryInProgress) return;
    let dx=0, dy=0;
    if(GS.input.up)dy-=1; if(GS.input.down)dy+=1; if(GS.input.left)dx-=1; if(GS.input.right)dx+=1;
    if(dx&&dy){ const k=.7071; dx*=k; dy*=k; }
    this.x+=dx*this.stats.moveSpeed*GS.dt; this.y+=dy*this.stats.moveSpeed*GS.dt; if(dx!==0) this.facing=Math.sign(dx);
    GS.camera.x = M.lerp(GS.camera.x,this.x,10*GS.dt); GS.camera.y = M.lerp(GS.camera.y,this.y,10*GS.dt);
    this.weapons.forEach(w=>w.update());
    if(this.hp<this.stats.maxHp && this.stats.regen>0){
      this.regenTimer+=GS.dt; if(this.regenTimer>=1){ this.hp=Math.min(this.stats.maxHp,this.hp+this.stats.regen); this.regenTimer=0; const dt=new DamageText(this.x,this.y,this.stats.regen,false); dt.color='#00a99c'; GS.damageTexts.push(dt); }
    }
    if(this.invulnTimer>0) this.invulnTimer-=GS.dt;
    if(Math.abs(this.x)>50000) this.x=0; if(Math.abs(this.y)>50000) this.y=0;
  }
  draw(){
    this.weapons.forEach(w=>w.draw&&w.draw());

    if(this.invulnTimer>0 && Math.floor(GS.time*20)%2===0) return;

    const cx=C.WIDTH/2, cy=C.HEIGHT/2, ctx=GS.ctx;
    ctx.save(); ctx.translate(cx,cy);
    const ringAngle=GS.time*2; ctx.rotate(ringAngle);
    ctx.strokeStyle='rgba(0,169,156,0.65)'; ctx.lineWidth=3;
    Draw.glow('rgba(0,169,156,0.7)',12,0.8);
    ctx.beginPath(); ctx.arc(0,0,this.r*1.65,0,Math.PI*1.8); ctx.stroke();
    Draw.resetGlow(); ctx.restore();
const img = GS.playerImg;
if (img && GS.playerImgReady) {
  const sx = this.x - GS.camera.x + C.WIDTH/2;
  const sy = this.y - GS.camera.y + C.HEIGHT/2;
  const size = this.r * 2;

  // 동그랗게 마스크 후 사진 그리기
  ctx.save();
  ctx.beginPath();
  ctx.arc(sx, sy, this.r, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(img, sx - size/2, sy - size/2, size, size);
  ctx.restore();

  // 테두리 + 글로우
  Draw.glow(C.COLORS.player,22);
  ctx.beginPath();
  ctx.arc(sx, sy, this.r, 0, Math.PI * 2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.stroke();
  Draw.resetGlow();
} else {
  // 로드 전 폴백(기존 원)
  Draw.glow(C.COLORS.player,22);
  Draw.circle(this.x,this.y,this.r,C.COLORS.player,'#fff',2);
  Draw.resetGlow();
}
    const bw=40,bh=6;
    ctx.fillStyle=C.COLORS.hpBg; ctx.fillRect(C.WIDTH/2-bw/2,C.HEIGHT/2+this.r+5,bw,bh);
    ctx.fillStyle=C.COLORS.hp; ctx.fillRect(C.WIDTH/2-bw/2,C.HEIGHT/2+this.r+5,bw*(this.hp/this.stats.maxHp),bh);
  }
  takeDamage(amount){
    if(this.invulnTimer>0||GS.state!=='running') return;
    const dmg=Math.max(1, amount - this.stats.armor); this.hp-=dmg; this.invulnTimer=.5; GS.screenShake=5;
    const dt=new DamageText(this.x,this.y,dmg,false); dt.color='#ff85a2'; GS.damageTexts.push(dt);
    if(GS.audio) GS.audio.sfxHurt(); if(this.hp<=0) gameOver();
  }
  gainXp(amount){ this.xp+=amount; if(this.xp>=this.nextLevelXp){ this.xp-=this.nextLevelXp; this.levelUp(); } updateHud(); }
  levelUp(){
    this.level++; this.nextLevelXp=Math.floor(8 + this.level*4*(1+this.level*.03));
    if(GS.audio) GS.audio.sfxLevelUp(); GS.state='levelup'; generateUpgrades();
  }
  addWeapon(w){ this.weapons.push(w); w.level=1; }
}

class Enemy extends Entity{
  constructor(cfg,x,y){
    super(x,y,cfg.r);
    const m = 1 + (GS.stageIndex*.65);
    this.hp=cfg.hp*m; this.maxHp=this.hp;
    this.damage=cfg.dmg*m; this.speed=cfg.speed*(1+GS.stageIndex*.1);
    this.xp=cfg.xp; this.color=cfg.color; this.kbResist=cfg.kbResist||0;
    this.vx=0; this.vy=0; this.flash=0; this.auraTimer=0; this.bobOffset=M.rand(0,Math.PI*2);
    this.shoots=cfg.shoots||false; if(this.shoots){ this.shootCd=cfg.shootCd||3; this.shootTimer=M.rand(1,this.shootCd); }
  }
  update(){
    if(GS.victoryInProgress) return;
    const a=M.angle(this.x,this.y,GS.player.x,GS.player.y);
    this.vx=M.lerp(this.vx, Math.cos(a)*this.speed, 5*GS.dt);
    this.vy=M.lerp(this.vy, Math.sin(a)*this.speed, 5*GS.dt);
    this.x+=this.vx*GS.dt; this.y+=this.vy*GS.dt;
    if(M.collides(this,GS.player)) GS.player.takeDamage(this.damage);
    if(this.flash>0) this.flash-=GS.dt; if(this.auraTimer>0) this.auraTimer-=GS.dt;
    if(M.distSq(this.x,this.y,GS.player.x,GS.player.y) > (C.WIDTH*2)**2) this.active=false;
    if(this.shoots){ this.shootTimer-=GS.dt; if(this.shootTimer<=0){ this.shoot(); this.shootTimer=this.shootCd; } }
  }
  shoot(){
    if(GS.audio) GS.audio.sfxEnemyShoot();
    const a=M.angle(this.x,this.y,GS.player.x,GS.player.y), speed=200;
    GS.enemyProjectiles.push(new EnemyProjectile(this.x,this.y,6,Math.cos(a)*speed,Math.sin(a)*speed,this.damage*.7,3,this.color));
  }
  draw(){
    const col=this.flash>0?'#fff':this.color, bob=Math.sin(GS.time*5+this.bobOffset)*2;
    Draw.circle(this.x,this.y+bob,this.r,col);
    Draw.circle(this.x-this.r/2,this.y+this.r/3+bob,this.r*.6,col);
    Draw.circle(this.x+this.r/2,this.y+this.r/3+bob,this.r*.6,col);
    const cx=this.x-GS.camera.x+C.WIDTH/2, cy=this.y-GS.camera.y+C.HEIGHT/2+bob, ctx=GS.ctx;
    if(cx>-this.r&&cx<C.WIDTH+this.r&&cy>-this.r&&cy<C.HEIGHT+this.r){
      ctx.strokeStyle='rgba(0,0,0,.5)'; ctx.lineWidth=2;
      const eyeX=this.r*.4, eyeY=this.r*.1, eyeW=this.r*.25;
      ctx.beginPath(); ctx.moveTo(cx-eyeX,cy-eyeY); ctx.lineTo(cx-eyeX+eyeW,cy+eyeY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx+eyeX,cy-eyeY); ctx.lineTo(cx+eyeX-eyeW,cy+eyeY); ctx.stroke();
    }
    if (this.name) {
      const y = this.y + bob - this.r - 12;
      const x = this.x;
      const nctx = GS.ctx;
      const sx = x - GS.camera.x + C.WIDTH / 2;
      const sy = y - GS.camera.y + C.HEIGHT / 2;

      nctx.save();
      nctx.font = "bold 18px 'DNFBitBit', sans-serif";
      nctx.textAlign = "center";

      nctx.lineWidth = 5;
      nctx.strokeStyle = "rgba(0,0,0,0.85)";
      nctx.strokeText(this.name, sx, sy);

      nctx.lineWidth = 2;
      nctx.strokeStyle = "rgba(255,255,255,0.5)";
      nctx.strokeText(this.name, sx, sy);

      nctx.fillStyle = "#fffdf0";
      nctx.fillText(this.name, sx, sy);

      nctx.shadowColor = "rgba(255,255,200,0.35)";
      nctx.shadowBlur = 3;

      nctx.restore();
    }
  }
  takeDamage(amount,isCrit,kb,ang){
    this.hp-=amount; this.flash=.1; GS.damageTexts.push(new DamageText(this.x,this.y,amount,isCrit));
    const kbf=Math.max(0,kb-this.kbResist); this.x+=Math.cos(ang)*kbf*GS.dt*2; this.y+=Math.sin(ang)*kbf*GS.dt*2; this.vx=0; this.vy=0;
    if(this.hp<=0) this.die();
  }
  die(){
    this.active=false; GS.kills++; GS.gems.push(new ExperienceOrb(this.x,this.y,this.xp));
    if(Math.random()<.05) GS.potions.push(new HealthPotion(this.x,this.y));
    updateHud();
  }
}
class StandardBoss extends Enemy{
  constructor(cfg,x,y){
    super(cfg,x,y); this.shootTimer=M.rand(2,4); this.shootCd=4; this.projectileSpeed=220*(1+(GS.stageIndex?GS.stageIndex*.2:0));
  }
  update(){
    super.update(); if(GS.victoryInProgress) return;
    this.shootTimer-=GS.dt; if(this.shootTimer<=0){ this.shoot(); this.shootTimer=this.shootCd+M.rand(-.5,.5); }
  }
  shoot(){
    if(GS.audio) GS.audio.playTone(300,'sawtooth',.3,.2);
    const spawn=(x,y,a,s)=>{ const p=new EnemyProjectile(x,y,7,Math.cos(a)*s,Math.sin(a)*s,this.damage,4,this.color); GS.enemyProjectiles.push(p); return p; };
    const dx=GS.player.x-this.x, dy=GS.player.y-this.y, ang=Math.atan2(dy,dx);
    if(GS.stageIndex===0){
      for(let i=-1;i<=1;i++) spawn(this.x,this.y, ang + i*.25, this.projectileSpeed);
    }else if(GS.stageIndex===1){
      for(let i=-3;i<=3;i++) spawn(this.x,this.y, ang + i*.2, this.projectileSpeed);
    }else if(GS.stageIndex===2){
      const n=12;
      for(let i=0;i<n;i++){ const a=(i*(Math.PI*2/n)) + (ang*.2); spawn(this.x,this.y,a,this.projectileSpeed*.9); }
    }
  }
  die(){
    this.active=false; GS.kills++;
    const xpNeeded=Math.max(1, GS.player.nextLevelXp*.8);
    GS.gems.push(new ExperienceOrb(this.x,this.y,xpNeeded));
    nextStage(); updateHud();
  }
}
class FinalBoss extends StandardBoss{
  constructor(cfg,x,y){ super(cfg,x,y); this.teleportTimer=5; this.shootTimer=2.5; this.summonTimer=8; this.projectileSpeed=250*(1+(GS.stageIndex?GS.stageIndex*.2:0)); }
  update(){
    super.update(); if(GS.victoryInProgress) return;
    this.teleportTimer-=GS.dt; if(this.teleportTimer<=0){ this.teleport(); this.teleportTimer=M.rand(4,6); }
    this.summonTimer-=GS.dt; if(this.summonTimer<=0){ this.summonMinions(); this.summonTimer=M.rand(7,10); }
  }
  teleport(){
    if(GS.audio) GS.audio.playTone(200,'sine',.5,.4,400);
    const a=M.rand(0,Math.PI*2), d=M.rand(200,C.WIDTH/2.5);
    this.x=GS.player.x+Math.cos(a)*d; this.y=GS.player.y+Math.sin(a)*d;
  }
  shoot(){
    if(GS.audio) GS.audio.playTone(440,'triangle',.2,.3,-100);
    const spawn=(x,y,a,s)=>{ const p=new EnemyProjectile(x,y,8,Math.cos(a)*s,Math.sin(a)*s,this.damage*.8,4,'#9400D3'); GS.enemyProjectiles.push(p); return p; };
    const dx=GS.player.x-this.x, dy=GS.player.y-this.y, ang=Math.atan2(dy,dx);
    const n=5, spread=.4;
    for(let i=0;i<n;i++){ const a=ang+M.lerp(-spread,spread, i/(n-1)); spawn(this.x,this.y,a,this.projectileSpeed*1.2); }
    setTimeout(()=>{
      if(!this.active) return;
      const wave=8; for(let i=0;i<wave;i++){ const a=(GS.time*3) + (i*(Math.PI*2/wave)); spawn(this.x,this.y,a,this.projectileSpeed*.8); }
    },500);
  }
  summonMinions(){
    if(GS.audio) GS.audio.playTone(150,'sawtooth',.8,.3);
    for(let i=0;i<3;i++){
      const a=M.rand(0,Math.PI*2), d=this.r+20, sx=this.x+Math.cos(a)*d, sy=this.y+Math.sin(a)*d;
      GS.enemies.push(new Enemy(E_DEFS[M.randInt(0,1)], sx, sy));
    }
  }
  die(){
    this.active=false; GS.kills++;
    const xpNeeded=Math.max(1, GS.player.nextLevelXp*1.0);
    GS.gems.push(new ExperienceOrb(this.x,this.y,xpNeeded)); updateHud();
    initiateVictorySequence(this.x,this.y);
  }
}

const E_DEFS = [
  {r:10,hp:10, speed:120,dmg:5,  xp:2,  color:C.COLORS.e1},
  {r:12,hp:20, speed:80, dmg:8,  xp:4,  color:C.COLORS.e2},
  {r:12,hp:40, speed:90, dmg:10, xp:5,  color:C.COLORS.e3},
  {r:10,hp:25, speed:150,dmg:12, xp:6,  color:C.COLORS.e4, kbResist:50, shoots:true, shootCd:3.5},
  {r:20,hp:250,speed:40, dmg:20, xp:30, color:C.COLORS.e5, kbResist:200},
];
const STAGE_BOSS_DEFS = [
  {r:35,hp:500,  speed:60,dmg:20,xp:0,color:'#FF9800', kbResist:600},
  {r:40,hp:1500, speed:65,dmg:25,xp:0,color:'#4CAF50', kbResist:700},
  {r:45,hp:4000, speed:70,dmg:30,xp:0,color:'#2196F3', kbResist:800},
  {r:50,hp:5000, speed:75,dmg:35,xp:0,color:'#673AB7', kbResist:900},
];

const STAGES = [
  { name:"소통과 복지", enemyTypes:[0,1] },
  { name:"교육과 취업", enemyTypes:[1,2,3] },
  { name:"시설, 학생 자치", enemyTypes:[2,3,4,0] },
  { name:"환경, 문화, 참여", enemyTypes:[0,1,2,3,4] }
];

const STAGE_SKILL_SETS={
  1:[ {base:Wand,name:"내 친구 드리미"}, {base:OrbitingBlade,name:"공약 RE;dream"}, {base:Boomerang,name:"JNU CONNECT : 제주대학교를 잇는 소통의 시작"},
      {base:Beam,name:"JNU-패스 도입"}, {base:Axe,name:"DREAM 천원 샵"}, {base:Aura,name:"드림 장학금"} ],
  2:[ {base:Wand,name:"수강신청 대기 순번제"}, {base:OrbitingBlade,name:"JNU Career Camp"}, {base:Boomerang,name:"예산 의결 학생 참여제"},
      {base:Beam,name:"학점 인정 인턴십 확대"}, {base:Axe,name:"Dream 융합 트랙 가이드"}, {base:Aura,name:"학내 학생 공간 확보"} ],
  3:[ {base:Wand,name:"DREAM SPACE IN JNU"}, {base:OrbitingBlade,name:"학생회관 냉난방 시스템 확립"}, {base:Boomerang,name:"제2운동장 환경 개선"},
      {base:Beam,name:"DOR+MUNITY"}, {base:Axe,name:"교양동 프린터기 설치"}, {base:Aura,name:"주차 사전정산 시스템 도입"} ],
  4:[ {base:Wand,name:"친환경 허브 캠퍼스 프로젝트"}, {base:OrbitingBlade,name:"Green JNU Challenge"}, {base:Boomerang,name:"드림 포인트제"},
      {base:Beam,name:"모두의 출범식"}, {base:Axe,name:"문화의 날"}, {base:Aura,name:"드림"} ]
};


const STAGE_PASSIVE_NAMES={
  1:{might:'학생 열정',speed:'발로 뛰기',area:'서귀포 통학버스 노선 확대',cd:'기획력 향상',amount:'팀 시너지',magnet:'소통력',health:'드림의 결속',regen:'휴식의 시간'},
  2:{might:'전공 지식',speed:'빠른 이력서 작성',area:'넓은 인맥',cd:'효율적인 시간 관리',amount:'자격증 추가',magnet:'취업 정보 수집',health:'강철 체력',regen:'힐링 스터디'},
  3:{might:'학생회관 냉난방 시스템 확립',speed:'빠른 하자 보수',area:'와이파이 증폭',cd:'정후문 환경 개선',amount:'CCTV 추가 설치',magnet:'민원 접수',health:'안전 제일',regen:'정기 점검'},
  4:{might:'문화적 영향력',speed:'축제 준비 가속',area:'다채로운 이벤트',cd:'빠른 무대 전환',amount:'앵콜 공연',magnet:'관객 유치',health:'분리수거함 증설',regen:'캠퍼스 정화'}
};
const STAGE_ENEMY_NAMES={
  1:["정보의 제약","소통 채널 부족","교통비 부담","물가 상승","등록금 부담","버스 노선 부족"],
  2:["수강신청 실패","트랙과정 정보 부족","취업 걱정","인턴십 경험 부족"],
  3:["학내 학생공간 부족","냉난방 시설 부족","프린터기 부족","기숙사 불편사항","정후문 불편사항","차량 혼잡"],
  4:["벌레 문제","환경 오염","에너지 낭비","학우들의 적은 관심","학우들 적은 참여율"]
};
const STAGE_BACKGROUNDS={1:['#fce4ec','#fffde7'], 2:['#e3f2fd','#f3e5f5'], 3:['#fff8e1','#fff3e0'], 4:['#e8f5e9','#ede7f6']};

function applyStageBackgroundColors(colors){
  const [c1,c2]=colors||['#b8e0d8','#eafcf7'];
  const root=document.documentElement;
  if(root){
    root.style.setProperty('--stage-bg-top', c1);
    root.style.setProperty('--stage-bg-bottom', c2);
  }
}
applyStageBackgroundColors(STAGE_BACKGROUNDS[1]);

function updatePassiveNames(stageNum){
  const map=STAGE_PASSIVE_NAMES[stageNum]; if(!map) return;
  PASSIVE_POOL.forEach(p=>{ if(map[p.id]) p.name=map[p.id]; });
}
function nextStage(){
  if(GS._stageTransitioning) return;
  GS._stageTransitioning=true;
  if(GS.stageIndex>=STAGES.length-1) return;
  GS.stageIndex++;
  const stage=STAGES[GS.stageIndex]; GS.bossHasSpawned=false;
  GS.stageTitle={text:`STAGE ${GS.stageIndex+1} - ${stage.name}`, timer:2.5};
  updatePassiveNames(GS.stageIndex+1);
  const set=STAGE_SKILL_SETS[GS.stageIndex+1]; if(set){ GS.player.weapons.forEach(w=>{ const m=set.find(s=>w instanceof s.base); if(m) w.name=m.name; }); }
  const names=STAGE_ENEMY_NAMES[GS.stageIndex+1]; if(names) GS.currentEnemyNames=names;
  const bg=STAGE_BACKGROUNDS[GS.stageIndex+1]; if(bg) GS.currentBg=bg;
  applyStageBackgroundColors(GS.currentBg);
  GS.gradientCache=null;
  setTimeout(()=>{GS._stageTransitioning=false;},2000);
}

Draw.background=function(padding=0){
  if(!GS.gradientCache){
    const ctx=GS.ctx;
    const [c1,c2]=GS.currentBg||['#b8e0d8','#eafcf7'];
    const g=ctx.createLinearGradient(0,0,0,C.HEIGHT);
    g.addColorStop(0,c1);
    g.addColorStop(1,c2);
    GS.gradientCache = g;
    applyStageBackgroundColors([c1,c2]);
  }
  const ctx=GS.ctx;
  const pad=Math.ceil(padding);
  ctx.fillStyle = GS.gradientCache;
  ctx.fillRect(-pad,-pad,C.WIDTH+pad*2,C.HEIGHT+pad*2);
};
function spawnBoss(bossDef,isFinal=false){
  if(GS.audio) GS.audio.playTone(80,'sawtooth',1.0,.4);
  GS.bossAlert={text:'!!! BOSS ALERT !!!', life:3};
  const a=M.rand(0,Math.PI*2), d=C.WIDTH/2+100, x=GS.player.x+Math.cos(a)*d, y=GS.player.y+Math.sin(a)*d;
  let boss = isFinal ? new FinalBoss(bossDef,x,y) : new StandardBoss(bossDef,x,y);
  const mult=1+GS.stageIndex*.4; boss.damage*=mult; if(isFinal) boss.damage*=.5;
  if(boss.attackCooldown!==undefined) boss.attackCooldown=Math.max(.3, boss.attackCooldown-GS.stageIndex*.2);
  if(boss.projectileSpeed!==undefined) boss.projectileSpeed*=1+GS.stageIndex*.2;
  boss.speed*=Math.min(1.3, 1+GS.stageIndex*.05);
  GS.enemies.push(boss);
}
function checkCollisions(){
  const enemies=GS.enemies;
  if(enemies.length===0) return;
  for(const p of GS.projectiles){
    if(!p.active) continue;
    const px=p.x, py=p.y, pr=p.r;
    for(const e of enemies){
      if(!e.active) continue;
      if(p.hitList.includes(e)) continue;
      const sumR = pr + e.r;
      const dx = px - e.x;
      if(Math.abs(dx) > sumR) continue;
      const dy = py - e.y;
      if(Math.abs(dy) > sumR) continue;
      if(M.distSq(px,py,e.x,e.y) <= sumR*sumR){
        p.onHit(e); p.hitList.push(e);
        if(!p.active) break;
      }
    }
  }
}
function generateUpgrades(){
  const container=document.getElementById('upgradeContainer'); container.innerHTML='';
  document.getElementById('levelUpScreen').classList.remove('hidden');
  let options=[];
  GS.player.weapons.forEach(w=>{ if(w.level < w.maxLevel) options.push({type:'weapon_up', obj:w}); });
  if(GS.player.weapons.length<6){
    WEAPON_POOL.forEach(Cls=>{
      if(!GS.player.weapons.some(w=>w instanceof Cls)) options.push({type:'weapon_new', cls:Cls});
    });
  }
  PASSIVE_POOL.forEach(p=>{
    const lvl=GS.player.passives[p.id]||0; if(lvl<5) options.push({type:'passive', def:p, lvl});
  });
  if(options.length===0) options.push({type:'heal'});
  options.sort(()=>Math.random()-.5);
  const luckBonus = GS.player.stats.luck>1.2 ? 1 : 0;
  const choices = options.slice(0, Math.min(3+luckBonus, options.length));
  choices.forEach(choice=>{
    const card=document.createElement('div'); card.className='upgrade-card';
    let title,desc,typeStr,iconCol,isNew=false;
    if(choice.type==='weapon_up'){
      title=`${choice.obj.name} (Lv ${choice.obj.level+1})`; desc=choice.obj.getDescription(); typeStr='WEAPON UPGRADE'; iconCol=choice.obj.iconColor;
    }else if(choice.type==='weapon_new'){
      const temp=new choice.cls(); const current=STAGE_SKILL_SETS[GS.stageIndex+1]; const info=current?.find(s=>s.base===choice.cls);
      title = info? info.name : temp.name; desc=temp.getDescription(); typeStr='NEW WEAPON'; iconCol=temp.iconColor; isNew=true;
    }else if(choice.type==='passive'){
      title=`${choice.def.name} (Lv ${choice.lvl+1})`; desc=choice.def.desc; typeStr='PASSIVE'; iconCol=choice.def.icon; if(choice.lvl===0) isNew=true;
    }else{ title='달콤한 휴식'; desc='체력 30% 회복'; typeStr='CONSUMABLE'; iconCol='#f88'; }
    card.innerHTML=`
      <div class="upgrade-icon" style="background:${iconCol}"></div>
      <div class="upgrade-title">${title}</div>
      <div class="upgrade-type">${typeStr}</div>
      <div class="upgrade-desc">${desc}</div>
      ${isNew?'<div class="new-tag">NEW!</div>':''}
    `;
    card.onclick=()=>selectUpgrade(choice);
    container.appendChild(card);
  });
}
function selectUpgrade(choice){
  if(GS.audio) GS.audio.playTone(880,'sine',.1,.5);
  if(choice.type==='weapon_up'){ choice.obj.level++; }
  else if(choice.type==='weapon_new'){
    const w=new choice.cls(); const set=STAGE_SKILL_SETS[GS.stageIndex+1]; const info=set?.find(s=>w instanceof s.base); if(info) w.name=info.name; GS.player.addWeapon(w);
  }else if(choice.type==='passive'){
    choice.def.apply(GS.player.stats); GS.player.passives[choice.def.id]=(GS.player.passives[choice.def.id]||0)+1;
  }else if(choice.type==='heal'){ GS.player.hp=Math.min(GS.player.stats.maxHp, GS.player.hp + GS.player.stats.maxHp*.3); }
  document.getElementById('levelUpScreen').classList.add('hidden'); GS.state='running'; GS.lastTime=performance.now();
}

function initiateVictorySequence(x,y){
  GS.victoryInProgress=true; GS.enemies=[];
  let duration=2500, interval=100, elapsed=0;
  const id=setInterval(()=>{
    GS.screenShake = 20*(1-(elapsed/duration));
    spawnParticles(x,y,C.COLORS.xp1,30); spawnParticles(x,y,C.COLORS.xp3,15); if(GS.audio) GS.audio.sfxHit();
    elapsed+=interval;
  }, interval);
  setTimeout(()=>{ clearInterval(id); GS.screenShake=0; GS.victoryInProgress=false; victory(); }, duration);
}
function spawnEnemies(){
  if(GS.victoryInProgress) return;
  if(GS.player.level >= (GS.stageIndex+1)*5 && !GS.bossHasSpawned){
    GS.bossHasSpawned=true; const def=STAGE_BOSS_DEFS[GS.stageIndex]; const isFinal = GS.stageIndex===STAGE_BOSS_DEFS.length-1; spawnBoss(def,isFinal); return;
  }
  if(GS.bossHasSpawned) return;
  GS.spawnTimer-=GS.dt; if(GS.spawnTimer<=0){
    const spawnInterval=Math.max(.05, .4 - (GS.player.level*.025) - (GS.stageIndex*.1)); GS.spawnTimer=spawnInterval;
    const stage=STAGES[GS.stageIndex], list=stage.enemyTypes;
    const type=list[M.randInt(0,list.length-1)];
    const def=E_DEFS[type];
    if(def.shoots && Math.random()>.15) return;

    if(GS.enemies.length >= DEVICE.enemyCap) return;
    const angle=M.rand(0,Math.PI*2);
    const radius=Math.hypot(C.WIDTH*0.5,C.HEIGHT*0.5)+50;
    const px=GS.player.x, py=GS.player.y;
    const x=px+Math.cos(angle)*radius;
    const y=py+Math.sin(angle)*radius;
    const enemy=new Enemy(def,x,y);
    if(GS.currentEnemyNames) enemy.name=GS.currentEnemyNames[M.randInt(0,GS.currentEnemyNames.length-1)];
    GS.enemies.push(enemy);
  }
}
function drawStageTitle(){
  if(GS.stageTitle && GS.stageTitle.timer>0){
    const a=Math.min(1, GS.stageTitle.timer); GS.ctx.globalAlpha=a;
    Draw.text(GS.stageTitle.text, GS.player.x, GS.player.y - C.HEIGHT/3, 24, '#003d38', 'center');
    GS.ctx.globalAlpha=1; GS.stageTitle.timer-=GS.dt;
  }
}

function update(){
  if(GS.time >= 180 && !GS.gameOver){ GS.gameOver=true; endGame("시간 초과! 3분 내 클리어 실패"); return; }
  spawnEnemies();
  GS.player.update();

  const maxParticles = DEVICE.isMobile ? 50 : GS.particles.length;
  for (let i = 0; i < maxParticles && i < GS.particles.length; i++) {
    GS.particles[i].update();
  }

  let pw = 0;
  for (let i = 0; i < GS.particles.length; i++) {
    if (GS.particles[i].active) GS.particles[pw++] = GS.particles[i];
  }
  GS.particles.length = pw;

  stepEntities(GS.enemies);
  stepEntities(GS.projectiles);
  stepEntities(GS.enemyProjectiles);
  stepEntities(GS.gems);
  stepEntities(GS.potions);
  stepEntities(GS.damageTexts);
  checkCollisions();
  if(GS.screenShake>0) GS.screenShake -= GS.dt*20;
  if(GS.bossAlert.life>0) GS.bossAlert.life -= GS.dt;
}
function render(){
  const ctx=GS.ctx; ctx.save();
  let shakeX=0, shakeY=0, pad=0;
  if(GS.screenShake>0){
    shakeX=M.rand(-GS.screenShake,GS.screenShake);
    shakeY=M.rand(-GS.screenShake,GS.screenShake);
    pad=Math.ceil(Math.max(Math.abs(shakeX), Math.abs(shakeY)));
    ctx.translate(shakeX,shakeY);
  }

  if (DEVICE.isMobile) {
    if (!GS.bgBuffer || GS.bgBuffer.width !== C.WIDTH || GS.bgBuffer.height !== C.HEIGHT) {
      GS.bgBuffer = document.createElement("canvas");
      GS.bgBuffer.width = C.WIDTH;
      GS.bgBuffer.height = C.HEIGHT;
      const bctx = GS.bgBuffer.getContext("2d");
      bctx.fillStyle = "#e6f5f2";
      bctx.fillRect(0, 0, C.WIDTH, C.HEIGHT);
    }
    if(pad>0){
      ctx.drawImage(GS.bgBuffer, 0, 0, C.WIDTH, C.HEIGHT, -pad, -pad, C.WIDTH+pad*2, C.HEIGHT+pad*2);
    }else{
      ctx.drawImage(GS.bgBuffer, 0, 0);
    }
  } else {
    Draw.background(pad);
  }

  const player = GS.player;
  const px = player.x, py = player.y;
  const xCull = DEVICE.cullX, yCull = DEVICE.cullY;
  const withinView = (ox,oy)=> Math.abs(ox - px) <= xCull && Math.abs(oy - py) <= yCull;
  for(const e of GS.gems){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const p of GS.potions){ if(!withinView(p.x,p.y)) continue; p.draw(); }
  for(const e of GS.particles){ if(!withinView(e.x,e.y)) continue; e.draw(); }

  if (GS.enemies.length > 1 && (GS.frameCount % 3 === 0)) {
    GS.enemies.sort((a, b) => a.y - b.y);
  }
  for(const e of GS.enemies){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  player.draw();
  for(const e of GS.projectiles){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const e of GS.enemyProjectiles){ if(!withinView(e.x,e.y)) continue; e.draw(); }
  for(const e of GS.damageTexts){ if(!withinView(e.x,e.y)) continue; e.draw(); }

  if (!DEVICE.isMobile) {
    const grad = GS.ctx.createRadialGradient(C.WIDTH / 2, C.HEIGHT / 2, C.HEIGHT / 2, C.WIDTH / 2, C.HEIGHT / 2, C.WIDTH / 1.5);
    grad.addColorStop(0, 'transparent');
    grad.addColorStop(1, 'rgba(0,0,0,.1)');
    GS.ctx.fillStyle = grad;
    GS.ctx.fillRect(-pad, -pad, C.WIDTH + pad*2, C.HEIGHT + pad*2);
  }

  if(GS.bossAlert.life>0){
    const alpha=Math.min(1,GS.bossAlert.life), size=40+(3-GS.bossAlert.life)*5; ctx.globalAlpha=alpha;
    Draw.text(GS.bossAlert.text, GS.player.x, GS.player.y - C.HEIGHT/3, size, '#b30000'); ctx.globalAlpha=1;
  }

  const fontSize = innerWidth < 768 ? Math.floor(16 * 0.7) : 16;
  ctx.font = `${fontSize}px 'Press Start 2P'`; ctx.textAlign="center"; ctx.fillStyle="#003d38"; ctx.strokeStyle="#fff"; ctx.lineWidth=4;
  const stageName=STAGES[GS.stageIndex]?.name||"", stageText=`STAGE ${GS.stageIndex+1} - ${stageName}`, x=C.WIDTH/2, y=85; ctx.strokeText(stageText,x,y); ctx.fillText(stageText,x,y);
  drawStageTitle(); ctx.restore();
}
function updateHud(){
  const p=GS.player;
  if(!p) return;
  const xpPct=(p.xp/p.nextLevelXp)*100;
  if(HUD.xpBar) HUD.xpBar.style.width = `${xpPct}%`;
  const fontSize = innerWidth < 768 ? 10 : 14;
  if(HUD.levelText){
    HUD.levelText.style.fontSize = `${fontSize}px`;
    HUD.levelText.innerText = `LV ${p.level}`;
  }
  if(HUD.timer) HUD.timer.innerText = M.formatTime(GS.time);
  if(HUD.killCount) HUD.killCount.innerText = `✨ ${GS.kills}`;
}
function gameLoop(t = performance.now()) {
  if (!GS.lastTime) GS.lastTime = t;
  let raw = (t - GS.lastTime) / 1000;
  GS.lastTime = t;

  if (DEVICE.isMobile) raw = Math.min(Math.max(raw, 0.01), 0.025);
  else raw = Math.min(Math.max(raw, 0.008), 0.033);
  GS.smoothedDt = GS.smoothedDt ? (GS.smoothedDt * 0.9 + raw * 0.1) : raw;
  GS.dt = GS.smoothedDt;

  if (!GS.lowPerfCounter) GS.lowPerfCounter = 0;
  if (raw > 0.035) GS.lowPerfCounter++;
  else GS.lowPerfCounter = Math.max(0, GS.lowPerfCounter - 1);
  GS.lowPerfMode = GS.lowPerfCounter > 5;

  if (GS.state === 'running') {
    GS.time += GS.dt;
    GS.frameCount++;
    update();
    render();
    updateHud();
  } else {
    render();
  }

  requestAnimationFrame(gameLoop);
}

function initGame(){
  GS.player=new Player(); GS.enemies=[]; GS.projectiles=[]; GS.enemyProjectiles=[]; GS.gems=[]; GS.particles=[]; GS.damageTexts=[]; GS.potions=[];
  GS.particlePool=[];
  const particlePoolSize = DEVICE.isMobile ? 100 : DEVICE.particleCap;
  for(let i=0;i<particlePoolSize;i++) GS.particlePool.push(new Particle(0,0,'#fff',0,0,0));
  GS.time=0; GS.kills=0; GS.camera={x:0,y:0}; GS.spawnTimer=1.8; GS.bossAlert={text:'',life:0};
  GS.startTime=null; GS.gameOver=false; GS.victoryInProgress=false; GS.stageIndex=0;
  const initial=STAGES[GS.stageIndex]; GS.stageTitle={text:`STAGE 1 - ${initial.name}`, timer:2.5};
  GS.currentBg=STAGE_BACKGROUNDS[GS.stageIndex+1];
  applyStageBackgroundColors(GS.currentBg);

  GS.gradientCache=null;
  GS.bossHasSpawned=false; GS.level5BossTriggered=false; GS.level10BossTriggered=false; GS.level15BossTriggered=false; GS.level20BossTriggered=false;
  GS.currentEnemyNames=STAGE_ENEMY_NAMES[GS.stageIndex+1];
  updatePassiveNames(1);
  const set=STAGE_SKILL_SETS[1]; if(set){ GS.player.weapons.forEach(w=>{ const s=set.find(x=>w instanceof x.base); if(s) w.name=s.name; }); }
  if(!GS.audio) GS.audio=new AudioSys(); GS.audio.ctx.resume();
  GS.state='running'; GS.lastTime=performance.now(); GS.smoothedDt=0;

  GS.glowIntensity = 1 * PERF.score;
  GS.particleDensity = 1 * PERF.score;
  GS.enemySpawnRate = 1 * PERF.score;
  document.querySelectorAll('.overlay').forEach(el=>el.classList.add('hidden'));
  setupJoystick();
  if(!GS.loopActive){
    GS.loopActive=true;
    requestAnimationFrame(gameLoop);
  }
}
function togglePause(){
  if(GS.state==='running'){
    GS.state='paused'; document.getElementById('pauseMenu').classList.remove('hidden');
    let html='<h3>Weapons</h3>'; GS.player.weapons.forEach(w=> html += `<p style="color:${w.iconColor}">${w.name}: Lv ${w.level}</p>`);
    html+='<h3>Stats</h3>'; const s=GS.player.stats;
    html+=`<p>Might: ${Math.round(s.might*100)}%</p><p>Speed: ${s.moveSpeed}</p><p>Cooldown: ${Math.round(s.cooldown*100)}%</p>`;
    document.getElementById('statsContainer').innerHTML=html;
  }else if(GS.state==='paused'){
    GS.state='running'; document.getElementById('pauseMenu').classList.add('hidden'); GS.lastTime=performance.now();
  }
}
function gameOver(){
  GS.state='gameover'; if(GS.audio) GS.audio.sfxDie();

  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('goTitle').style.fontSize = `${Math.floor(32 * (innerWidth < 768 ? 0.7 : 1))}px`;
  document.getElementById('goTime').style.fontSize = `${fontSize}px`;
  document.getElementById('goKills').style.fontSize = `${fontSize}px`;
  document.getElementById('goLevel').style.fontSize = `${fontSize}px`;
  document.getElementById('goTitle').innerText="꿈속에 갇혔습니다...";
  document.getElementById('goTime').innerText=`버틴 시간: ${M.formatTime(GS.time)}`;
  document.getElementById('goKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('goLevel').innerText=`성장 레벨: ${GS.player.level}`;
  setTimeout(()=> document.getElementById('gameOverScreen').classList.remove('hidden'), 1000);
}
function endGame(msg){
  GS.state='gameover'; if(GS.audio) GS.audio.sfxDie();
  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('goTitle').style.fontSize = `${Math.floor(32 * (innerWidth < 768 ? 0.7 : 1))}px`;
  document.getElementById('goTime').style.fontSize = `${fontSize}px`;
  document.getElementById('goKills').style.fontSize = `${fontSize}px`;
  document.getElementById('goLevel').style.fontSize = `${fontSize}px`;
  document.getElementById('goTitle').innerText=msg||"꿈속에 갇혔습니다...";
  document.getElementById('goTime').innerText=`버틴 시간: ${M.formatTime(GS.time)}`;
  document.getElementById('goKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('goLevel').innerText=`성장 레벨: ${GS.player.level}`;
  setTimeout(()=> document.getElementById('gameOverScreen').classList.remove('hidden'), 1000);
}
function victory(){
  if(GS.state==='victory') return; GS.state='victory'; GS.enemies=[];

  const fontSize = innerWidth < 768 ? 10 : 14;
  document.getElementById('vKills').style.fontSize = `${fontSize}px`;
  document.getElementById('vKills').innerText=`물리친 악몽: ${GS.kills}`;
  document.getElementById('victoryScreen').classList.remove('hidden');
}

addEventListener('keydown',e=>{
  const k=e.key.toLowerCase(); if('wasd'.includes(k)||k.startsWith('arrow')){
    if(k==='w'||k==='arrowup') GS.input.up=true;
    if(k==='s'||k==='arrowdown') GS.input.down=true;
    if(k==='a'||k==='arrowleft') GS.input.left=true;
    if(k==='d'||k==='arrowright') GS.input.right=true;
  }
  if(k==='p'||k==='escape'){ if(GS.state==='running'||GS.state==='paused') togglePause(); }
});
addEventListener('keyup',e=>{
  const k=e.key.toLowerCase(); if('wasd'.includes(k)||k.startsWith('arrow')){
    if(k==='w'||k==='arrowup') GS.input.up=false;
    if(k==='s'||k==='arrowdown') GS.input.down=false;
    if(k==='a'||k==='arrowleft') GS.input.left=false;
    if(k==='d'||k==='arrowright') GS.input.right=false;
  }
});

document.getElementById('btnStart').onclick = initGame;
document.getElementById('btnRestart').onclick=initGame;
document.getElementById('btnRestartVic').onclick=initGame;
document.getElementById('btnResume').onclick=togglePause;

function openPolicyLink(event){
  const link=event.currentTarget && event.currentTarget.getAttribute('data-policy-link');
  if(!link) return;
  window.location.href=link;
}
document.getElementById('btnPolicyGO').onclick=openPolicyLink;
document.getElementById('btnPolicyVic').onclick=openPolicyLink;

resize();
Draw.background();

function setupJoystick(){
  const base=document.getElementById('joystick-base'), thumb=document.getElementById('joystick-thumb');
  const ua = navigator.userAgent;
  const isTouchDevice = (
    'ontouchstart' in window ||
    navigator.maxTouchPoints > 0 ||
    navigator.msMaxTouchPoints > 0 ||
    /iPad|Tablet|PlayBook|Silk/i.test(ua) ||
    (/Macintosh/i.test(ua) && 'ontouchend' in document) ||
    window.matchMedia && window.matchMedia('(pointer:coarse)').matches
  );
  if (!isTouchDevice) return;

  let active=false, startX=0, startY=0;
  if(!GS.player) GS.player={}; if(!GS.player.moveDir) GS.player.moveDir={x:0,y:0};

  document.addEventListener('touchstart', e=>{
    const target = e.target;
    if(target.closest('#hud') || target.closest('.overlay') || target.closest('button')) return;

    active=true;
    const t=e.touches[0];
    startX=t.clientX;
    startY=t.clientY;

    const size = parseFloat(getComputedStyle(base).width);
    base.style.left = (startX - size/2) + 'px';
    base.style.top = (startY - size/2) + 'px';
    base.style.display = 'block';
    base.classList.add('active');

    thumb.style.transform='translate(0,0)';
  }, {passive:true});

  document.addEventListener('touchmove', e=>{
    if(!active) return;
    const t=e.touches[0];
    const x=t.clientX - startX;
    const y=t.clientY - startY;

    const size = parseFloat(getComputedStyle(base).width);
    const max=size/2 - 10;
    const dist=Math.sqrt(x*x+y*y);

    const nx=M.clamp(x/max,-1,1);
    const ny=M.clamp(y/max,-1,1);
    GS.player.moveDir={x:nx,y:ny};

    thumb.style.transform=`translate(${nx*max*0.5}px, ${ny*max*0.5}px)`;
  }, {passive:true});

  document.addEventListener('touchend', ()=>{
    if(!active) return;
    active=false;
    GS.player.moveDir={x:0,y:0};
    thumb.style.transform='translate(0,0)';
    base.classList.remove('active');
    setTimeout(()=>{ if(!active) base.style.display='none'; }, 200);
  });
}

(function(){
  const ua = navigator.userAgent;
  const isTouchDevice =
  'ontouchstart' in window ||
  navigator.maxTouchPoints > 0 ||
  navigator.msMaxTouchPoints > 0 ||
  /iPad|Tablet|PlayBook|Silk/i.test(ua) ||
  (/Macintosh/i.test(ua) && 'ontouchend' in document);
  if (!isTouchDevice) return;  
  const orig=Player.prototype.update;
  Player.prototype.update=function(){
    if(GS.victoryInProgress) return;
    let dx=0, dy=0;
    if(this.moveDir && (this.moveDir.x||this.moveDir.y)){ dx=this.moveDir.x; dy=this.moveDir.y; }
    else{ if(GS.input.up)dy-=1; if(GS.input.down)dy+=1; if(GS.input.left)dx-=1; if(GS.input.right)dx+=1; }
    if(dx&&dy){ const k=.7071; dx*=k; dy*=k; }
    this.x+=dx*this.stats.moveSpeed*GS.dt; this.y+=dy*this.stats.moveSpeed*GS.dt; if(dx!==0) this.facing=Math.sign(dx);
    GS.camera.x=M.lerp(GS.camera.x,this.x,10*GS.dt); GS.camera.y=M.lerp(GS.camera.y,this.y,10*GS.dt);
    this.weapons.forEach(w=>w.update());
    if(this.hp<this.stats.maxHp && this.stats.regen>0){
      this.regenTimer+=GS.dt; if(this.regenTimer>=1){ this.hp=Math.min(this.stats.maxHp,this.hp+this.stats.regen); this.regenTimer=0;
        const dt=new DamageText(this.x,this.y,this.stats.regen,false); dt.color='#00a99c'; GS.damageTexts.push(dt);
      }
    }
    if(this.invulnTimer>0) this.invulnTimer-=GS.dt;
    if(Math.abs(this.x)>50000) this.x=0; if(Math.abs(this.y)>50000) this.y=0;
  };
})();

</script>
</body>
</html>
