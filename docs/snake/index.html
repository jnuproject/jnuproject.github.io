<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>드림 키우기</title>
  <style>
    :root {
      color-scheme: dark;
      --footer-banner-offset: calc(60px + env(safe-area-inset-bottom, 0px));
      --joystick-size: clamp(150px, 36vw, 180px);
      --boost-size: calc(var(--joystick-size) * 0.42);
    }
    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at 50% 25%, #1f2a3a 0%, #0b1119 65%);
      overflow: hidden;
      font-family: "Pretendard", "Segoe UI", Arial, sans-serif;
      color: #f1f5f9;
    }
    #footerBanner {
      width: 100%;
      text-align: center;
      padding: 0.8rem 1rem calc(0.8rem + env(safe-area-inset-bottom, 0px));
      background: linear-gradient(90deg, #00bfa5, #0097a7);
      color: #fff;
      font-weight: 600;
      font-size: clamp(0.9rem, 2vw, 1.1rem);
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      box-shadow: 0 -3px 10px rgba(0, 0, 0, 0.1);
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }
    #overlay {
      position: fixed;
      top: 18px;
      left: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 5;
      pointer-events: none;
    }
    #scoreBoard {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    #score {
      font-size: clamp(18px, 3vw, 28px);
      font-weight: 600;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
    }
    #remaining {
      font-size: clamp(14px, 2.4vw, 22px);
      font-weight: 500;
      color: #e2e8f0;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
    #modal {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, rgba(11, 15, 23, 0.92), rgba(4, 6, 10, 0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #modalContent {
      width: min(420px, 88vw);
      padding: clamp(26px, 6vw, 40px);
      border-radius: 20px;
      background: rgba(15, 25, 38, 0.9);
      box-shadow: 0 30px 80px rgba(3, 7, 18, 0.6);
      text-align: center;
    }
    #modalContent h1 {
      margin: 0 0 12px;
      font-size: clamp(26px, 7vw, 40px);
      letter-spacing: 0.8px;
    }
    #modalContent p {
      margin: 0 0 18px;
      line-height: 1.6;
      font-size: clamp(15px, 4vw, 17px);
      color: #cbd5f5;
    }
    #modalContent ul {
      list-style: none;
      padding: 0;
      margin: 0 0 22px;
      text-align: left;
      color: #94a3b8;
      font-size: clamp(13px, 3.6vw, 15px);
      display: grid;
      gap: 6px;
    }
    #startBtn {
      pointer-events: auto;
      cursor: pointer;
      border: none;
      border-radius: 999px;
      padding: 14px 36px;
      font-weight: 700;
      font-size: clamp(17px, 4.5vw, 20px);
      color: #0f172a;
      background: linear-gradient(120deg, #38bdf8 0%, #22d3ee 48%, #8b5cf6 100%);
      box-shadow: 0 18px 45px rgba(56, 189, 248, 0.45);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    #startBtn:active {
      transform: translateY(2px);
      box-shadow: 0 12px 28px rgba(56, 189, 248, 0.3);
    }
    @media (max-width: 640px) {
      #overlay {
        top: 12px;
        left: 12px;
      }
      #mobileControls {
        bottom: calc(24px + var(--footer-banner-offset));
      }
    }

    #mobileControls {
      position: fixed;
      bottom: calc(28px + var(--footer-banner-offset));
      left: 0;
      right: 0;
      padding: 0 clamp(16px, 6vw, 36px);
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: clamp(12px, 4vw, 28px);
      z-index: 8;
      pointer-events: none;
    }
    body.mobile #mobileControls {
      display: flex;
    }
    body:not(.mobile) #joystick {
      display: none;
    }
    #joystick {
      position: relative;
      width: var(--joystick-size);
      height: var(--joystick-size);
      pointer-events: auto;
      touch-action: none;
    }

    #boostButton {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      width: var(--boost-size);
      height: var(--boost-size);
      border-radius: 50%;
      border: none;
      font-weight: 700;
      font-size: clamp(12px, 2.8vw, 15px);
      color: #0f172a;
      background: radial-gradient(circle, rgba(250, 204, 21, 0.95) 0%, rgba(248, 113, 113, 0.95) 85%);
      box-shadow: 0 12px 30px rgba(248, 191, 78, 0.35);
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.2s ease;
      pointer-events: auto;
      z-index: 6;
      opacity: 0.92;
    }

    body.mobile #boostButton {
      position: relative;
      right: auto;
      top: auto;
      bottom: auto;
      transform: none;
      margin: 0;
      width: var(--boost-size);
      height: var(--boost-size);
      display: flex;
      align-items: center;
      justify-content: center;
      align-self: flex-end;
      font-size: clamp(14px, 4vw, 18px);
      pointer-events: auto;
    }

    #boostButton:active,
    #boostButton.active {
      transform: translateY(-50%) translateX(-2px) scale(0.98);
      box-shadow: 0 8px 22px rgba(248, 191, 78, 0.45);
      opacity: 1;
    }

    #boostButton:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: 0 6px 18px rgba(248, 191, 78, 0.25);
      transform: translateY(-50%);
    }

    body.mobile #boostButton:active,
    body.mobile #boostButton.active {
      transform: scale(0.96);
      box-shadow: 0 10px 22px rgba(248, 191, 78, 0.45);
    }

    body.mobile #boostButton:disabled {
      transform: none;
    }
    #joystickBase {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(59, 130, 246, 0.28) 0%, rgba(15, 23, 42, 0.65) 65%);
      border: 3px solid rgba(148, 163, 184, 0.45);
      box-shadow: 0 0 18px rgba(56, 189, 248, 0.45);
    }
    #joystickHandle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: clamp(70px, 18vw, 90px);
      height: clamp(70px, 18vw, 90px);
      border-radius: 50%;
      background: radial-gradient(circle, rgba(96, 165, 250, 0.9) 0%, rgba(37, 99, 235, 0.85) 85%);
      box-shadow: 0 0 14px rgba(37, 99, 235, 0.65);
      transform: translate(-50%, -50%);
      transition: transform 120ms ease-out;
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div id="overlay">
      <div id="scoreBoard">
        <div id="score">길이: 10</div>
        <div id="remaining">남은 난관: 99</div>
      </div>
  </div>
  <div id="mobileControls">
    <div id="joystick">
      <div id="joystickBase"></div>
      <div id="joystickHandle"></div>
    </div>
    <button id="boostButton" type="button" aria-pressed="false">부스트</button>
  </div>
  <div id="modal" role="dialog" aria-modal="true">
    <div id="modalContent">
      <h1>캠퍼스 서바이벌</h1>
      <p>F학점 경고, 과제 폭탄, 팀플 잠수조 같은 캠퍼스 난관이 99마리의 지렁이로 몰려옵니다. 먹이를 먹어 성장하며 마지막까지 버텨보세요.</p>
      <ul>
        <li>• 모바일은 왼쪽 조이스틱으로, 데스크톱은 마우스/터치로 방향을 조절하세요.</li>
        <li>• 지렁이는 자동으로 가속합니다. 방향만 부드럽게 유지하고 충돌을 피하세요.</li>
        <li>• 난관(적)에게 머리가 닿으면 탈락합니다. 마지막 1인이 되면 승리!</li>
      </ul>
      <button id="startBtn">게임 시작</button>
    </div>
  </div>

  <script>
    const DPR = window.devicePixelRatio || 1;
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    const scoreDOM = document.getElementById("score");
    const remainingDOM = document.getElementById("remaining");
    const modalDOM = document.getElementById("modal");
    const startBtn = document.getElementById("startBtn");
    const boostBtn = document.getElementById("boostButton");

    const IS_MOBILE = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent) || window.innerWidth < 768;

    const WORLD_SIZE = 9000;
    const SAFE_RADIUS = 360;
    const INVULNERABLE_FRAMES = 60;
    const FOOD_TARGET = Math.floor((WORLD_SIZE * WORLD_SIZE) / 42000);
    const FOOD_SOFT_CAP = Math.floor(FOOD_TARGET * 1.15);
    const FOOD_HARD_CAP = Math.floor(FOOD_TARGET * 1.35);
    const CAMERA_BASE_ZOOM = 1;
    const CAMERA_MIN_ZOOM = 0.54;
    const CAMERA_BASE_ZOOM_MOBILE = 0.95;
    const CAMERA_MIN_ZOOM_MOBILE = 0.38;
    const TOTAL_SNAKES = 100;
    const THREAT_COUNT = TOTAL_SNAKES - 1;
    const PLAYER_SIZE_SCALE = IS_MOBILE ? 0.78 : 1;
    const PLAYER_INITIAL_GROW = IS_MOBILE ? 22 : 30;
    const FOOD_CELL_SIZE = 220;
    const SNAKE_CELL_SIZE = 520;

    const PLAYER_BASE_SPEED = IS_MOBILE ? 2.32 : 2.5;
    const AI_BASE_SPEED = IS_MOBILE ? 2.12 : 2.32;
    const SPEED_PER_LENGTH = 0.001;
    const BOOST_MULTIPLIER = 1.62;
    const BOOST_DRAIN = 0.005;
    const BOOST_MIN_LENGTH = 24;
    const PLAYER_TURN_RATE = 0.11;
    const AI_TURN_RATE = 0.074;
    const AI_WANDER_DURATION = 2600;
    const AI_VIEW_DISTANCE = 820;
    const AI_AVOID_DISTANCE = 240;
    const AI_TARGET_REEVALUATE = 1020;
    const AI_FOOD_WEIGHT = 0.58;
    const AI_HEAD_WEIGHT = 0.28;
    const DIFFICULTY_RAMP_MS = 210000;

    if (remainingDOM) {
      remainingDOM.textContent = `남은 난관: ${THREAT_COUNT}`;
    }

    const palette = [
      "#38bdf8", "#f472b6", "#fbbf24", "#4ade80", "#c084fc",
      "#f87171", "#f97316", "#22d3ee", "#34d399", "#a855f7",
      "#facc15", "#fda4af", "#60a5fa", "#a3e635", "#fb7185",
    ];

    const threatNames = [
      "과제 폭탄", "기말고사", "대면발표", "팀플 지옥", "오픈북 금지",
      "레포트 마감", "깜짝퀴즈", "출석체크", "기숙사 점검", "리더십 세미나",
      "조별과제장", "프레젠테이션", "필기시험", "자격증 준비", "실험 리포트",
    ];

    const joystickElement = document.getElementById("joystick");
    const joystickBase = document.getElementById("joystickBase");
    const joystickHandle = document.getElementById("joystickHandle");

    if (IS_MOBILE) {
      document.body.classList.add("mobile");
    } else {
      document.body.classList.remove("mobile");
    }

    const joystickState = {
      active: false,
      identifier: null,
      vector: { x: 0, y: 0 },
    };

    const game = {
      snakes: [],
      foods: [],
      player: null,
      pointer: { x: 0, y: 0, active: false, strength: 0 },
      running: false,
      lastTs: performance.now(),
      camera: { x: 0, y: 0, zoom: IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM },
      playTimeMs: 0,
      threatsLeft: THREAT_COUNT,
      tick: 0,
      difficulty: 0,
      boostButtonActive: false,
    };

    const foodSpatial = {
      cellSize: FOOD_CELL_SIZE,
      cells: new Map(),
    };

    function getFoodCellKey(x, y) {
      const size = foodSpatial.cellSize;
      const cellX = Math.floor(x / size);
      const cellY = Math.floor(y / size);
      return `${cellX}:${cellY}`;
    }

    function registerFood(food) {
      const key = getFoodCellKey(food.x, food.y);
      food.cellKey = key;
      let bucket = foodSpatial.cells.get(key);
      if (!bucket) {
        bucket = [];
        foodSpatial.cells.set(key, bucket);
      }
      bucket.push(food);
    }

    function unregisterFood(food) {
      const key = food.cellKey;
      if (!key) return;
      const bucket = foodSpatial.cells.get(key);
      if (bucket) {
        const idx = bucket.indexOf(food);
        if (idx !== -1) bucket.splice(idx, 1);
        if (bucket.length === 0) foodSpatial.cells.delete(key);
      }
      food.cellKey = null;
    }

    function addFood(food) {
      registerFood(food);
      game.foods.push(food);
    }

    function removeFood(food) {
      if (!food) return;
      unregisterFood(food);
      const idx = game.foods.indexOf(food);
      if (idx !== -1) game.foods.splice(idx, 1);
    }

    function centerJoystickHandle() {
      if (!joystickHandle) return;
      joystickHandle.style.transform = "translate(-50%, -50%)";
    }

    function applyJoystickInput(nx, ny) {
      joystickState.vector.x = nx;
      joystickState.vector.y = ny;
      const magnitude = Math.min(1, Math.hypot(nx, ny));
      if (magnitude < 0.06) {
        game.pointer.active = false;
        game.pointer.strength = 0;
        return;
      }
      const pointerRadius = Math.min(canvas.width / DPR, canvas.height / DPR) * (IS_MOBILE ? 0.5 : 0.45);
      const centerX = canvas.width / (2 * DPR);
      const centerY = canvas.height / (2 * DPR);
      setPointerPosition(centerX + nx * pointerRadius, centerY + ny * pointerRadius);
    }

    function resetJoystick() {
      if (!IS_MOBILE) return;
      joystickState.active = false;
      joystickState.identifier = null;
      joystickState.vector.x = 0;
      joystickState.vector.y = 0;
      centerJoystickHandle();
      game.pointer.active = false;
      game.pointer.x = canvas.width / (2 * DPR);
      game.pointer.y = canvas.height / (2 * DPR);
      game.pointer.strength = 0;
      setBoostButtonState(false);
    }

    function updateJoystickFromTouch(touch) {
      if (!joystickBase || !joystickHandle) return;
      const rect = joystickBase.getBoundingClientRect();
      const baseRadius = rect.width / 2;
      const dx = touch.clientX - (rect.left + baseRadius);
      const dy = touch.clientY - (rect.top + baseRadius);
      let nx = dx / Math.max(baseRadius, 1);
      let ny = dy / Math.max(baseRadius, 1);
      const length = Math.hypot(nx, ny);
      if (length > 1) {
        nx /= length;
        ny /= length;
      }
      const handleTravel = baseRadius * 0.6;
      joystickHandle.style.transform = `translate(-50%, -50%) translate(${nx * handleTravel}px, ${ny * handleTravel}px)`;
      applyJoystickInput(nx, ny);
    }

    function onJoystickStart(e) {
      if (!IS_MOBILE || joystickState.active) return;
      const touch = e.changedTouches && e.changedTouches[0];
      if (!touch) return;
      joystickState.active = true;
      joystickState.identifier = touch.identifier;
      updateJoystickFromTouch(touch);
      e.preventDefault();
    }

    function onJoystickMove(e) {
      if (!IS_MOBILE || !joystickState.active) return;
      const touch = Array.from(e.changedTouches || []).find(t => t.identifier === joystickState.identifier);
      if (!touch) return;
      updateJoystickFromTouch(touch);
      e.preventDefault();
    }

    function onJoystickEnd(e) {
      if (!IS_MOBILE || !joystickState.active) return;
      const touch = Array.from(e.changedTouches || []).find(t => t.identifier === joystickState.identifier);
      if (!touch) return;
      resetJoystick();
      e.preventDefault();
    }

    function resize() {
      canvas.width = window.innerWidth * DPR;
      canvas.height = window.innerHeight * DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      if (IS_MOBILE && !joystickState.active) {
        centerJoystickHandle();
      }
    }
    resize();
    window.addEventListener("resize", resize);

    if (IS_MOBILE) {
      centerJoystickHandle();
      if (joystickElement) {
        joystickElement.addEventListener("touchstart", onJoystickStart, { passive: false });
        joystickElement.addEventListener("touchmove", onJoystickMove, { passive: false });
        joystickElement.addEventListener("touchend", onJoystickEnd, { passive: false });
        joystickElement.addEventListener("touchcancel", onJoystickEnd, { passive: false });
      }
    }

    if (boostBtn) {
      boostBtn.addEventListener("mousedown", handleBoostPress);
      boostBtn.addEventListener("mouseup", handleBoostRelease);
      boostBtn.addEventListener("mouseleave", handleBoostRelease);
      boostBtn.addEventListener("touchstart", handleBoostPress, { passive: false });
      boostBtn.addEventListener("touchend", handleBoostRelease, { passive: false });
      boostBtn.addEventListener("touchcancel", handleBoostRelease, { passive: false });
    }
    window.addEventListener("mouseup", handleBoostRelease);
    window.addEventListener("keydown", e => {
      if (!isBoostKey(e.code)) return;
      if (e.repeat) return;
      handleBoostPress(e);
    });
    window.addEventListener("keyup", e => {
      if (!isBoostKey(e.code)) return;
      handleBoostRelease(e);
    });

    function randRange(range) {
      return (Math.random() * 2 - 1) * range;
    }

    function randFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function rotateTowards(current, target, maxStep) {
      let diff = Math.atan2(Math.sin(target - current), Math.cos(target - current));
      if (Math.abs(diff) <= maxStep) {
        return target;
      }
      return current + Math.sign(diff) * maxStep;
    }

    function hexToRgb(hex) {
      let normalized = hex.replace("#", "");
      if (normalized.length === 3) {
        normalized = normalized.split("").map(c => c + c).join("");
      }
      const num = parseInt(normalized, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255,
      };
    }

    function rgbToHex({ r, g, b }) {
      const toHex = v => {
        const clamped = Math.max(0, Math.min(255, Math.round(v)));
        return clamped.toString(16).padStart(2, "0");
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixColor(color, target, ratio) {
      const src = hexToRgb(color);
      const dst = hexToRgb(target);
      return rgbToHex({
        r: src.r * (1 - ratio) + dst.r * ratio,
        g: src.g * (1 - ratio) + dst.g * ratio,
        b: src.b * (1 - ratio) + dst.b * ratio,
      });
    }

    function lighten(color, ratio) {
      return mixColor(color, "#ffffff", ratio);
    }

    function darken(color, ratio) {
      return mixColor(color, "#000000", ratio);
    }

    function isBoostKey(code) {
      return code === "Space" || code === "ShiftLeft" || code === "ShiftRight";
    }

    function getDifficulty() {
      const timeFactor = clamp(game.playTimeMs / DIFFICULTY_RAMP_MS, 0, 1);
      const eliminationFactor = THREAT_COUNT > 0
        ? clamp((THREAT_COUNT - game.threatsLeft) / THREAT_COUNT, 0, 1)
        : 0;
      const lengthFactor = game.player
        ? clamp((game.player.segments.length - game.player.baseLength) / 260, 0, 1)
        : 0;
      const composite = timeFactor * 0.4 + eliminationFactor * 0.2 + lengthFactor * 0.25;
      return clamp(composite, 0, 1);
    }

    function generateThreat() {
      const name = randFrom(threatNames);
      const color = randFrom(palette);
      return { name, color };
    }

    function safeSpawn(minDistance = SAFE_RADIUS, maxAttempts = 30) {
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const pos = {
          x: randRange(WORLD_SIZE * 0.45),
          y: randRange(WORLD_SIZE * 0.45),
        };
        let ok = true;
        for (const snake of game.snakes) {
          const dx = pos.x - snake.head.x;
          const dy = pos.y - snake.head.y;
          if (Math.hypot(dx, dy) < minDistance + snake.radius * 1.5) {
            ok = false;
            break;
          }
        }
        if (ok) return pos;
      }
      return {
        x: randRange(WORLD_SIZE * 0.45),
        y: randRange(WORLD_SIZE * 0.45),
      };
    }

    function isGameActive() {
      return game.running && game.player && game.player.alive;
    }

    function canPlayerScore() {
      return game.player && game.player.alive && game.running;
    }

    function setPointerPosition(x, y) {
      game.pointer.x = x;
      game.pointer.y = y;
      const centerX = canvas.width / (2 * DPR);
      const centerY = canvas.height / (2 * DPR);
      const dx = x - centerX;
      const dy = y - centerY;
      const maxRadius = Math.max(canvas.width, canvas.height) / (2 * DPR);
      game.pointer.strength = clamp(Math.hypot(dx, dy) / Math.max(60, maxRadius), 0, 1);
      game.pointer.active = true;
    }

    function setBoostButtonState(active) {
      const playable = Boolean(game.running && game.player && game.player.alive);
      const pressed = playable && Boolean(active);
      game.boostButtonActive = pressed;
      if (boostBtn) {
        boostBtn.disabled = !playable;
        boostBtn.classList.toggle("active", pressed);
        boostBtn.setAttribute("aria-pressed", pressed ? "true" : "false");
      }
    }

    function handleBoostPress(e) {
      if (e) {
        if (e.type === "touchstart" || e.type === "keydown" || (e.type === "mousedown" && e.target === boostBtn)) {
          e.preventDefault();
        }
      }
      if (boostBtn && boostBtn.disabled) return;
      setBoostButtonState(true);
    }

    function handleBoostRelease(e) {
      if (e) {
        if (e.type === "touchend" || e.type === "touchcancel" || e.type === "keydown" || e.type === "keyup") {
          e.preventDefault();
        }
      }
      setBoostButtonState(false);
    }

    class Food {
      constructor(x, y, value = 4) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = 4 + value * 0.8;
        this.color = randFrom(palette);
        this.cellKey = null;
      }
      draw(camera) {
        const width = canvas.width / DPR;
        const height = canvas.height / DPR;
        const zoom = camera.zoom;
        const { x: sx, y: sy } = worldToScreen(this.x, this.y);
        if (sx < -50 || sx > width + 50 || sy < -50 || sy > height + 50) return;

        const radius = this.radius * zoom;
        const gradient = ctx.createRadialGradient(sx, sy, radius * 0.2, sx, sy, radius);
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(1, this.color);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    let snakeIdCounter = 0;

    class Snake {
      constructor(opts) {
        this.id = snakeIdCounter++;
        this.isPlayer = opts.isPlayer;
        this.name = opts.name;
        this.color = opts.color;
        this.sizeScale = opts.sizeScale ?? 1;
        this.baseLength = Math.max(36, Math.round(76 * this.sizeScale));
        this.segments = [];
        this.radius = 16 * this.sizeScale;
        this.spacing = 6 * this.sizeScale;
        this.length = this.baseLength;
        this.direction = Math.random() * Math.PI * 2;
        this.alive = true;
        this.score = 14;
        this.invulnerable = INVULNERABLE_FRAMES;
        const baseScatter = this.isPlayer ? 0.08 : 0.1;
        const speedSeed = this.isPlayer ? PLAYER_BASE_SPEED : AI_BASE_SPEED;
        this.baseSpeed = speedSeed + (Math.random() - 0.5) * baseScatter;
        this.speedMod = 1;
        this.turnRate = this.isPlayer ? PLAYER_TURN_RATE : AI_TURN_RATE + (Math.random() - 0.5) * 0.015;
        this.boosting = false;
        this.boostMeter = 1;
        this.boostCooldown = 0;
        this.boostDropTimer = 0;
        this.aiState = {
          mode: this.isPlayer ? "player" : "wander",
          timer: 0,
          targetAngle: this.direction,
          lastDecision: performance.now(),
        };
        this.spawn(opts.x, opts.y);
      }

      spawn(x, y) {
        this.segments = [];
        for (let i = 0; i < this.length; i++) {
          this.segments.push({
            x: x - Math.cos(this.direction) * i * this.spacing,
            y: y - Math.sin(this.direction) * i * this.spacing,
          });
        }
      }

      get head() {
        return this.segments[0];
      }

      grow(amount) {
        if (!Number.isFinite(amount) || amount <= 0) return;
        if (this.isPlayer && !canPlayerScore()) return;
        this.score += amount;
        this.length += amount;
        const tail = this.segments[this.segments.length - 1];
        for (let i = 0; i < amount; i++) {
          this.segments.push({ x: tail.x, y: tail.y });
        }
        this.recalculateBody();
      }

      shrink(amount) {
        if (!Number.isFinite(amount) || amount <= 0) return;
        const targetLength = Math.max(this.baseLength, this.length - amount);
        while (this.length > targetLength && this.segments.length > this.baseLength) {
          this.segments.pop();
          this.length -= 1;
        }
        this.score = Math.max(10, this.score - amount * 0.7);
        this.recalculateBody();
      }

      recalculateBody() {
        const baseRadius = 12 + Math.min(30, this.segments.length / 11);
        this.radius = baseRadius * this.sizeScale;
        this.spacing = (5 + Math.min(3, baseRadius / 9)) * this.sizeScale;
      }

      currentSpeed() {
        const sizeBonus = Math.min(3, (this.segments.length - this.baseLength) * SPEED_PER_LENGTH);
        const diff = game.difficulty ?? 0;
        const difficultyBonus = diff * (this.isPlayer ? 0.18 : 0.24);
        return (this.baseSpeed + sizeBonus + difficultyBonus) * this.speedMod;
      }

      updateBoost(deltaMs) {
        if (!this.isPlayer) {
          this.boosting = false;
          this.speedMod = 1;
          this.boostCooldown = Math.max(0, this.boostCooldown - deltaMs);
          this.boostMeter = Math.min(1, this.boostMeter + BOOST_DRAIN * 0.5 * deltaMs);
          this.boostDropTimer = 0;
          return;
        }

        const hasReserve = this.segments.length > this.baseLength + BOOST_MIN_LENGTH && this.boostMeter > 0.08;
        const pointerWants = game.pointer.active && game.pointer.strength > 0.7;
        const buttonWants = game.boostButtonActive;
        const wantsBoost = hasReserve && (pointerWants || buttonWants);

        if (wantsBoost && this.boostCooldown <= 0) {
          this.boosting = true;
        } else if (!wantsBoost) {
          this.boosting = false;
        }

        if (this.boosting) {
          this.speedMod = BOOST_MULTIPLIER;
          this.boostCooldown = 200;
          this.boostMeter = Math.max(0, this.boostMeter - BOOST_DRAIN * deltaMs);
          if (this.boostMeter <= 0) this.boosting = false;
          this.boostDropTimer += deltaMs;
          if (this.boostDropTimer > 110) {
            this.boostDropTimer = 0;
            if (this.segments.length > this.baseLength + 8) {
              const tail = this.segments[this.segments.length - 1];
              addFood(new Food(tail.x, tail.y, 2.5 + Math.random() * 2.5));
              this.shrink(1);
            }
          }
        } else {
          this.speedMod = 1;
          this.boostCooldown = Math.max(0, this.boostCooldown - deltaMs);
          this.boostMeter = Math.min(1, this.boostMeter + BOOST_DRAIN * 0.35 * deltaMs);
          this.boostDropTimer = 0;
        }
      }

      updatePlayerHeading(delta) {
        if (!game.running || !this.alive || !game.pointer.active) return;
        const { x, y } = screenToWorld(game.pointer.x, game.pointer.y);
        const dx = x - this.head.x;
        const dy = y - this.head.y;
        const targetAngle = Math.atan2(dy, dx);
        const maxTurn = this.turnRate * delta * 3.6;
        this.direction = rotateTowards(this.direction, targetAngle, maxTurn);
      }

    pickFoodTarget() {
        if (!game.foods.length) return null;
        const diff = game.difficulty ?? 0;
        const viewDistance = AI_VIEW_DISTANCE * (1 + diff * 0.45);
        let best = null;
        let bestScore = Infinity;
        const samples = Math.min(18, game.foods.length);
        for (let i = 0; i < samples; i++) {
          const food = game.foods[Math.floor(Math.random() * game.foods.length)];
          if (!food) continue;
          const dx = food.x - this.head.x;
          const dy = food.y - this.head.y;
          const dist = Math.hypot(dx, dy);
          if (dist > viewDistance * 1.25) continue;
          if (dist < bestScore) {
            bestScore = dist;
            best = food;
          }
        }
        return best;
      }

      computeAvoidanceVector(diff) {
        const head = this.head;
        const maxDist = (AI_AVOID_DISTANCE * 1.05) + diff * 180;
        const maxDistSq = maxDist * maxDist;
        let ax = 0;
        let ay = 0;
        let weightSum = 0;

        for (const other of game.snakes) {
          if (!other.alive) continue;
          const step = other === this ? 6 : 4;
          const segments = other.segments;
          for (let i = other === this ? 6 : 0; i < segments.length; i += step) {
            const seg = segments[i];
            const dx = head.x - seg.x;
            const dy = head.y - seg.y;
            const distSq = dx * dx + dy * dy;
            if (distSq < 1 || distSq > maxDistSq) continue;
            const dist = Math.sqrt(distSq);
            if (other === this && dist < this.radius * 1.2) continue;
            const weight = ((maxDist - dist) / maxDist) * 0.7;
            ax += (dx / dist) * weight;
            ay += (dy / dist) * weight;
            weightSum += weight;
          }
        }

        const magnitude = Math.hypot(ax, ay);
        if (weightSum <= 0 || magnitude < 0.02) return null;
        return {
          angle: Math.atan2(ay, ax),
          strength: clamp(magnitude / (1.4 + diff), 0, 0.85),
        };
      }

      updateAIHeading(deltaMs) {
        const delta = deltaMs / (1000 / 60);
        this.aiState.timer -= deltaMs;
        const player = game.player && game.player.alive ? game.player : null;
        const head = this.head;
        let desiredAngle = this.aiState.targetAngle;
        const diff = game.difficulty ?? 0;
        const viewDistance = AI_VIEW_DISTANCE * (1 + diff * 0.45);
        const avoidDistance = AI_AVOID_DISTANCE * (1 + diff * 0.25);
        const reevaluateDelay = AI_TARGET_REEVALUATE * (1 - diff * 0.35);
        const wanderSpan = AI_WANDER_DURATION * (0.5 + diff * 0.6);

        const maybeRecalc = () => {
          const now = performance.now();
        if (this.aiState.timer > 0 && now - this.aiState.lastDecision < reevaluateDelay) return;
        this.aiState.lastDecision = now;

        // Avoid close heads first
        if (player && player !== this) {
          const pdx = player.head.x - head.x;
          const pdy = player.head.y - head.y;
          const pdist = Math.hypot(pdx, pdy);
          if (pdist < avoidDistance + this.radius * 2) {
            this.aiState.mode = "evade";
            this.aiState.timer = 500 + Math.random() * 500;
            desiredAngle = Math.atan2(head.y - player.head.y, head.x - player.head.x) + randRange(0.5);
            this.boosting = false;
            return;
          }
          if (pdist < viewDistance && Math.random() < AI_HEAD_WEIGHT) {
            this.aiState.mode = "pursue";
            this.aiState.timer = 820 + Math.random() * 520;
            desiredAngle = Math.atan2(pdy, pdx);
            this.boosting = false;
            return;
          }
        }

        const food = this.pickFoodTarget();
        if (food && Math.random() < AI_FOOD_WEIGHT) {
          this.aiState.mode = "forage";
          this.aiState.timer = 760 + Math.random() * 520;
          desiredAngle = Math.atan2(food.y - head.y, food.x - head.x) + randRange(0.2);
          this.boosting = false;
          return;
        }

        this.aiState.mode = "wander";
        this.aiState.timer = wanderSpan * (0.6 + Math.random() * 0.6);
        desiredAngle = this.direction + randRange(1);
        this.boosting = false;
        };

        maybeRecalc();

        const avoidance = this.computeAvoidanceVector(diff);
        if (avoidance) {
          const bias = clamp(avoidance.strength * 0.65, 0, 0.75);
          const diffAngle = Math.atan2(Math.sin(avoidance.angle - desiredAngle), Math.cos(avoidance.angle - desiredAngle));
          desiredAngle += diffAngle * bias;
          if (avoidance.strength > 0.35) {
            this.boosting = false;
          }
        }

        const maxTurn = this.turnRate * delta * (this.aiState.mode === "evade" ? 4 : 2.8);
        desiredAngle += randRange(0.08 * (1 - diff * 0.4));
        this.direction = rotateTowards(this.direction, desiredAngle, maxTurn);
        this.aiState.targetAngle = desiredAngle;
      }

      advance(delta) {
        const distance = this.currentSpeed() * delta * 1.1;
        const newX = this.head.x + Math.cos(this.direction) * distance;
        const newY = this.head.y + Math.sin(this.direction) * distance;
        this.segments.unshift({ x: newX, y: newY });
        while (this.segments.length > this.length) {
          this.segments.pop();
        }
        for (let i = 1; i < this.segments.length; i++) {
          const prev = this.segments[i - 1];
          const seg = this.segments[i];
          const dx = seg.x - prev.x;
          const dy = seg.y - prev.y;
          const dist = Math.hypot(dx, dy);
          if (dist > this.spacing) {
            const ratio = this.spacing / dist;
            seg.x = prev.x + dx * ratio;
            seg.y = prev.y + dy * ratio;
          }
        }
      }

      keepInside() {
        // AI는 벽에서 더 멀리 떨어지도록, 플레이어는 벽 가까이 갈 수 있도록
        const margin = this.isPlayer ? 220 : 600;
        const bound = WORLD_SIZE / 2 - margin;
        let bounced = false;
        const head = this.head;
        if (head.x < -bound) {
          head.x = -bound;
          bounced = true;
        } else if (head.x > bound) {
          head.x = bound;
          bounced = true;
        }
        if (head.y < -bound) {
          head.y = -bound;
          bounced = true;
        } else if (head.y > bound) {
          head.y = bound;
          bounced = true;
        }
        if (bounced) {
          this.direction = Math.atan2(-Math.sin(this.direction), -Math.cos(this.direction));
        }
      }

      update(delta) {
        if (!this.alive) return;
        const deltaMs = delta * (1000 / 60);
        if (this.invulnerable > 0) {
          this.invulnerable = Math.max(0, this.invulnerable - delta);
        }
        this.updateBoost(deltaMs);
        if (this.isPlayer) {
          this.updatePlayerHeading(delta);
        } else {
          this.updateAIHeading(deltaMs);
        }
        this.advance(delta);
        this.keepInside();
        this.recalculateBody();
      }

      draw(camera) {
        if (!this.alive) return;
        const width = canvas.width / DPR;
        const height = canvas.height / DPR;
        const zoom = camera.zoom;
        const margin = Math.max(120 * zoom, this.radius * 3);
        const headScreen = worldToScreen(this.head.x, this.head.y);

        let visible =
          headScreen.x >= -margin && headScreen.x <= width + margin &&
          headScreen.y >= -margin && headScreen.y <= height + margin;

        if (!visible) {
          for (let i = 4; i < this.segments.length; i += 6) {
            const seg = this.segments[i];
            const screen = worldToScreen(seg.x, seg.y);
            if (screen.x >= -margin && screen.x <= width + margin &&
                screen.y >= -margin && screen.y <= height + margin) {
              visible = true;
              break;
            }
          }
          if (!visible) return;
        }

        const headX = headScreen.x;
        const headY = headScreen.y;
        const gradient = ctx.createLinearGradient(
          headX,
          headY,
          headX + Math.cos(this.direction) * 110 * zoom,
          headY + Math.sin(this.direction) * 110 * zoom
        );
        const headColor = this.boosting ? lighten(this.color, 0.55) : lighten(this.color, 0.38);
        const midColor = this.color;
        const tailColor = darken(this.color, 0.25);
        gradient.addColorStop(0, headColor);
        gradient.addColorStop(0.45, midColor);
        gradient.addColorStop(1, tailColor);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.radius * 1.12 * zoom;
        ctx.beginPath();
        for (let i = 0; i < this.segments.length; i += 2) {
          const seg = this.segments[i];
          const screen = worldToScreen(seg.x, seg.y);
          if (i === 0) ctx.moveTo(screen.x, screen.y);
          else ctx.lineTo(screen.x, screen.y);
        }
        ctx.stroke();

        ctx.save();
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.boosting ? "rgba(255, 248, 200, 0.55)" : `${lighten(this.color, 0.6)}80`;
        ctx.lineWidth = this.radius * 0.52 * zoom;
        ctx.beginPath();
        for (let i = 0; i < this.segments.length; i += 4) {
          const seg = this.segments[i];
          const screen = worldToScreen(seg.x, seg.y);
          if (i === 0) ctx.moveTo(screen.x, screen.y);
          else ctx.lineTo(screen.x, screen.y);
        }
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.translate(headX, headY);
        ctx.rotate(this.direction);

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radius * 0.9 * zoom, this.radius * 0.72 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(this.radius * 0.35 * zoom, -this.radius * 0.25 * zoom, this.radius * 0.2 * zoom, 0, Math.PI * 2);
        ctx.arc(this.radius * 0.35 * zoom, this.radius * 0.25 * zoom, this.radius * 0.2 * zoom, 0, Math.PI * 2);
        ctx.fill();

        if (this.invulnerable <= 0) {
          ctx.strokeStyle = this.boosting ? "#fb7185" : "#f43f5e";
          ctx.lineWidth = Math.max(2 * zoom, this.radius * 0.16 * zoom);
          ctx.beginPath();
          ctx.moveTo(this.radius * 0.7 * zoom, 0);
          ctx.lineTo(
            this.radius * 1.2 * zoom,
            Math.sin(performance.now() * 0.012) * this.radius * 0.3 * zoom
          );
          ctx.stroke();
        }
        ctx.restore();

        if (this.invulnerable > 0) {
          ctx.strokeStyle = "rgba(96, 165, 250, 0.45)";
          ctx.lineWidth = this.radius * 0.35 * zoom;
          ctx.beginPath();
          ctx.arc(headX, headY, this.radius * 1.25 * zoom, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillStyle = this.isPlayer ? "#facc15" : "#e2e8f0";
        const fontSize = Math.max(12, (this.isPlayer ? 16 : 14) * zoom);
        ctx.font = `${fontSize}px "Segoe UI"`;
        ctx.fillText(
          this.isPlayer ? `나 (${Math.floor(this.score)})` : `${this.name}`,
          headX + 22 * zoom,
          headY - this.radius * zoom - 8 * zoom
        );
      }
    }

    function screenToWorld(sx, sy) {
      const zoom = game.camera.zoom || 1;
      return {
        x: sx / zoom + game.camera.x,
        y: sy / zoom + game.camera.y,
      };
    }

    function worldToScreen(wx, wy) {
      const zoom = game.camera.zoom || 1;
      return {
        x: (wx - game.camera.x) * zoom,
        y: (wy - game.camera.y) * zoom,
      };
    }

    function populateFoods() {
      game.foods.forEach(unregisterFood);
      game.foods.length = 0;
      foodSpatial.cells.clear();
      for (let i = 0; i < FOOD_TARGET; i++) {
        const pos = safeSpawn(0, 1);
        addFood(new Food(pos.x, pos.y, Math.random() * 4 + 2));
      }
    }

    function spawnAI(count) {
      const amount = Math.max(0, Math.floor(count));
      for (let i = 0; i < amount; i++) {
        const pos = safeSpawn();
        const threat = generateThreat();
        const color = threat.color || randFrom(palette);
        const bot = new Snake({
          x: pos.x,
          y: pos.y,
          color,
          name: threat.name,
          isPlayer: false,
          sizeScale: 1,
        });
        bot.grow(Math.floor(Math.random() * 120) + 40);
        game.snakes.push(bot);
      }
    }

    function dropFoodFromSnake(snake) {
      // 음식 드롭 수를 제한하여 성능 향상
      const dropInterval = Math.max(8, Math.floor(snake.segments.length / 15));
      const mobileDropCap = IS_MOBILE ? 28 : 50;
      const maxDrops = Math.min(mobileDropCap, Math.floor(snake.segments.length / (IS_MOBILE ? 3.6 : 3)));
      let dropped = 0;

      for (let i = 0; i < snake.segments.length && dropped < maxDrops; i += dropInterval) {
        const seg = snake.segments[i];
        const count = 2 + Math.floor(Math.random() * 2); // 3~5 -> 2~3으로 감소
        for (let j = 0; j < count && dropped < maxDrops; j++) {
          const offsetX = (Math.random() - 0.5) * snake.radius * 1.6;
          const offsetY = (Math.random() - 0.5) * snake.radius * 1.6;
          addFood(new Food(seg.x + offsetX, seg.y + offsetY, 4 + Math.random() * 4));
          dropped++;
        }
      }
    }

    function trimOldFoods(limit) {
      const excess = game.foods.length - limit;
      if (excess <= 0) return;
      const removed = game.foods.splice(0, excess);
      for (const food of removed) unregisterFood(food);
    }

    function enforceFoodCap() {
      if (game.foods.length <= FOOD_SOFT_CAP) return;
      if (game.foods.length > FOOD_HARD_CAP) {
        trimOldFoods(FOOD_HARD_CAP);
      }
      const trimmedTo = Math.floor(FOOD_TARGET * 1.1);
      const targetLength = Math.min(trimmedTo, FOOD_SOFT_CAP, FOOD_HARD_CAP);
      if (game.foods.length > targetLength) {
        trimOldFoods(targetLength);
      }
    }

    function killSnake(snake) {
      if (!snake.alive) return;
      snake.alive = false;
      dropFoodFromSnake(snake);
      updateRemaining();

      if (snake.isPlayer) {
        game.running = false;
        setBoostButtonState(false);
        game.pointer.active = false;
        game.pointer.strength = 0;
        scoreDOM.textContent = `길이: ${Math.floor(snake.score)}`;
        modalDOM.querySelector("h1").textContent = "게임 오버";
        modalDOM.querySelector("p").innerHTML = `최종 길이: ${Math.floor(snake.score)}<br/>다시 한 번 도전해 볼까요?`;
        startBtn.textContent = "다시 시작";
        modalDOM.style.display = "flex";
        if (IS_MOBILE) resetJoystick();
      }
      checkForVictory();
    }

    function handleVictory() {
      if (!game.player) return;
      game.running = false;
      setBoostButtonState(false);
      game.pointer.active = false;
      game.pointer.strength = 0;
      updateScore();
      updateRemaining();
      modalDOM.querySelector("h1").textContent = "최후의 1인!";
      modalDOM.querySelector("p").innerHTML = `축하합니다! 모든 캠퍼스 난관을 정복했습니다.<br/>최종 길이: ${Math.floor(game.player.score)}`;
      startBtn.textContent = "다시 시작";
      modalDOM.style.display = "flex";
      if (IS_MOBILE) resetJoystick();
    }

    function checkForVictory() {
      if (!game.player || !game.player.alive) return;
      let aliveCount = 0;
      for (const snake of game.snakes) {
        if (snake.alive) aliveCount += 1;
      }
      if (aliveCount === 1) {
        handleVictory();
      }
    }

    function collectFood(snake) {
      const head = snake.head;
      if (!head) return;
      const cellSize = foodSpatial.cellSize;
      const baseCellX = Math.floor(head.x / cellSize);
      const baseCellY = Math.floor(head.y / cellSize);

      for (let cx = baseCellX - 1; cx <= baseCellX + 1; cx++) {
        for (let cy = baseCellY - 1; cy <= baseCellY + 1; cy++) {
          const bucket = foodSpatial.cells.get(`${cx}:${cy}`);
          if (!bucket || bucket.length === 0) continue;
          for (let i = bucket.length - 1; i >= 0; i--) {
            const food = bucket[i];
            const dx = food.x - head.x;
            const dy = food.y - head.y;
            const maxRange = snake.radius + food.radius * 0.75;
            if (Math.abs(dx) > maxRange || Math.abs(dy) > maxRange) continue;
            if (dx * dx + dy * dy < maxRange * maxRange) {
              snake.grow(Math.ceil(food.value));
              removeFood(food);
            }
          }
        }
      }
      if (game.foods.length < FOOD_TARGET) {
        const pos = safeSpawn(0, 1);
        addFood(new Food(pos.x, pos.y, 3 + Math.random() * 4));
      }
    }

    function headHitsSnake(attacker, defender) {
      if (!attacker || !defender) return false;
      if (!attacker.alive || attacker.invulnerable > 0) return false;
      const attackerHead = attacker.head;
      if (!attackerHead) return false;
      const defenderHead = defender.head;
      if (!defenderHead) return false;

      const maxDist = (attacker.radius + defender.length * defender.spacing) * 1.4;
      const dx = defenderHead.x - attackerHead.x;
      const dy = defenderHead.y - attackerHead.y;
      if (Math.abs(dx) > maxDist || Math.abs(dy) > maxDist) return false;

      for (let i = 8; i < defender.segments.length; i += 2) {
        const seg = defender.segments[i];
        if (!seg) continue;
        const segDx = seg.x - attackerHead.x;
        const segDy = seg.y - attackerHead.y;
        const collisionDist = attacker.radius * 0.8;
        if (segDx * segDx + segDy * segDy < collisionDist * collisionDist) {
          killSnake(attacker);
          return true;
        }
      }
      return false;
    }

    function detectCollisions() {
      const aliveSnakes = game.snakes.filter(s => s.alive);
      if (!aliveSnakes.length) return;

      const cellSize = SNAKE_CELL_SIZE;
      const snakeGrid = new Map();

      for (const snake of aliveSnakes) {
        collectFood(snake);
        if (!snake.alive) continue;
        const head = snake.head;
        if (!head) continue;
        const cellX = Math.floor(head.x / cellSize);
        const cellY = Math.floor(head.y / cellSize);
        const key = `${cellX}:${cellY}`;
        let bucket = snakeGrid.get(key);
        if (!bucket) {
          bucket = [];
          snakeGrid.set(key, bucket);
        }
        bucket.push(snake);
      }

      for (const [key, bucket] of snakeGrid) {
        const [baseX, baseY] = key.split(":").map(Number);
        for (const snake of bucket) {
          if (!snake.alive || snake.invulnerable > 0) continue;
          const snakeHead = snake.head;
          if (!snakeHead) continue;

          for (let nx = baseX - 1; nx <= baseX + 1; nx++) {
            for (let ny = baseY - 1; ny <= baseY + 1; ny++) {
              const neighborBucket = snakeGrid.get(`${nx}:${ny}`);
              if (!neighborBucket) continue;
              for (const other of neighborBucket) {
                if (snake === other || !other.alive || other.invulnerable > 0) continue;
                if (snake.id > other.id) continue;

                if (headHitsSnake(snake, other)) {
                  if (snake.isPlayer) return;
                  if (!snake.alive) break;
                }
                if (!snake.alive) break;
                if (headHitsSnake(other, snake)) {
                  if (other.isPlayer) return;
                  continue;
                }
              }
              if (!snake.alive) break;
            }
            if (!snake.alive) break;
          }
        }
      }
    }

    function updateScore() {
      if (!game.player || !game.player.alive) return;
      scoreDOM.textContent = `길이: ${Math.floor(game.player.score)}`;
    }

    function updateRemaining() {
      let aliveCount = 0;
      for (const snake of game.snakes) {
        if (snake.alive) aliveCount += 1;
      }
      const playerAlive = game.player && game.player.alive ? 1 : 0;
      const threatsLeft = Math.max(0, aliveCount - playerAlive);
      game.threatsLeft = threatsLeft;
      if (remainingDOM) {
        remainingDOM.textContent = `남은 난관: ${threatsLeft}`;
      }
    }

    function updateCamera() {
      if (!game.player) return;
      const width = canvas.width / DPR;
      const height = canvas.height / DPR;
      const player = game.player;

      const baseZoom = IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM;
      const minZoom = IS_MOBILE ? CAMERA_MIN_ZOOM_MOBILE : CAMERA_MIN_ZOOM;
      const growth = Math.max(0, player.segments.length - player.baseLength);
      const growthDivisor = IS_MOBILE ? 120 : 220;
      const maxProgress = IS_MOBILE ? 1.4 : 1;
      const sizeProgress = clamp(growth / growthDivisor, 0, maxProgress);
      const desiredZoom = baseZoom - sizeProgress * (baseZoom - minZoom);
      const smoothing = IS_MOBILE ? 0.08 : 0.06;
      game.camera.zoom += (desiredZoom - game.camera.zoom) * smoothing;
      game.camera.zoom = clamp(game.camera.zoom, minZoom, baseZoom);

      const halfWidth = (width / game.camera.zoom) * 0.5;
      const halfHeight = (height / game.camera.zoom) * 0.5;
      const desiredX = player.head.x - halfWidth;
      const desiredY = player.head.y - halfHeight;

      const minX = -WORLD_SIZE / 2;
      const maxX = Math.max(minX, WORLD_SIZE / 2 - width / game.camera.zoom);
      const minY = -WORLD_SIZE / 2;
      const maxY = Math.max(minY, WORLD_SIZE / 2 - height / game.camera.zoom);

      const clampedX = clamp(desiredX, minX, maxX);
      const clampedY = clamp(desiredY, minY, maxY);

      game.camera.x += (clampedX - game.camera.x) * 0.12;
      game.camera.y += (clampedY - game.camera.y) * 0.12;
    }

    function drawBackground() {
      const tile = 160;
      const width = canvas.width / DPR;
      const height = canvas.height / DPR;
      const zoom = game.camera.zoom;
      const left = game.camera.x;
      const top = game.camera.y;
      const right = left + width / zoom;
      const bottom = top + height / zoom;
      const startX = Math.floor(left / tile) * tile;
      const startY = Math.floor(top / tile) * tile;

      ctx.fillStyle = "#0b0f17";
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = "rgba(56, 68, 90, 0.18)";
      ctx.lineWidth = 1;
      for (let x = startX; x <= right; x += tile) {
        const screenX = (x - left) * zoom;
        ctx.beginPath();
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, height);
        ctx.stroke();
      }
      for (let y = startY; y <= bottom; y += tile) {
        const screenY = (y - top) * zoom;
        ctx.beginPath();
        ctx.moveTo(0, screenY);
        ctx.lineTo(width, screenY);
        ctx.stroke();
      }

      ctx.strokeStyle = "rgba(148, 163, 184, 0.12)";
      ctx.lineWidth = 4;
      const bounds = WORLD_SIZE / 2;
      const rectX = (-bounds - left) * zoom;
      const rectY = (-bounds - top) * zoom;
      ctx.strokeRect(rectX, rectY, WORLD_SIZE * zoom, WORLD_SIZE * zoom);
    }

    function update(delta) {
      game.tick += delta;
      game.playTimeMs += delta * (1000 / 60);
      game.difficulty = getDifficulty();
      for (const snake of game.snakes) snake.update(delta);
      detectCollisions();
      updateCamera();
      updateScore();
      updateRemaining();
      if (game.foods.length > FOOD_SOFT_CAP) enforceFoodCap();
    }

    function draw() {
      drawBackground();
      for (const food of game.foods) food.draw(game.camera);
      for (const snake of game.snakes) snake.draw(game.camera);
    }

    function loop(ts) {
      const delta = Math.min(6, (ts - game.lastTs) / (1000 / 60));
      game.lastTs = ts;
      if (game.running && game.player) {
        update(delta);
        draw();
      } else {
        drawBackground();
        game.foods.forEach(food => food.draw(game.camera));
        game.snakes.forEach(snake => snake.draw(game.camera));
      }
      requestAnimationFrame(loop);
    }

    function startGame() {
      modalDOM.querySelector("h1").textContent = "캠퍼스 서바이벌";
      modalDOM.querySelector("p").innerHTML = `F학점 경고, 과제 폭탄, 팀플 잠수조 같은 캠퍼스 난관 ${THREAT_COUNT}마리를 뚫고 마지막 생존자가 되어보세요.`;
      startBtn.textContent = "게임 시작";
      game.snakes.length = 0;
      snakeIdCounter = 0;
      game.foods.forEach(unregisterFood);
      game.foods.length = 0;
      foodSpatial.cells.clear();
      game.camera.x = 0;
      game.camera.y = 0;
      game.camera.zoom = IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM;
      game.pointer.active = false;
      game.playTimeMs = 0;
      game.threatsLeft = THREAT_COUNT;
      game.tick = 0;
      game.pointer.strength = 0;
      populateFoods();

      const player = new Snake({
        x: 0,
        y: 0,
        color: "#38bdf8",
        name: "You",
        isPlayer: true,
        sizeScale: PLAYER_SIZE_SCALE,
      });
      player.grow(PLAYER_INITIAL_GROW);
      game.player = player;
      game.snakes.push(player);
      spawnAI(TOTAL_SNAKES - 1);
      updateRemaining();
      updateScore();

      game.running = true;
      game.lastTs = performance.now();
      setBoostButtonState(false);
      modalDOM.style.display = "none";
      setPointerPosition(canvas.width / (2 * DPR), canvas.height / (2 * DPR));
      if (IS_MOBILE) {
        resetJoystick();
      }
    }

    canvas.addEventListener("mousemove", e => {
      if (!isGameActive()) return;
      setPointerPosition(e.clientX, e.clientY);
    });

    canvas.addEventListener("mouseleave", () => {
      game.pointer.active = false;
      game.pointer.strength = 0;
      handleBoostRelease();
    });

    if (!IS_MOBILE) {
      canvas.addEventListener("touchstart", e => {
        if (!isGameActive()) return;
        const touch = e.touches[0];
        setPointerPosition(touch.clientX, touch.clientY);
      }, { passive: false });

      canvas.addEventListener("touchmove", e => {
        if (!isGameActive()) return;
        const touch = e.touches[0];
        setPointerPosition(touch.clientX, touch.clientY);
      }, { passive: false });

      canvas.addEventListener("touchend", () => {
        game.pointer.active = false;
        game.pointer.strength = 0;
      });
    }

    window.addEventListener("blur", () => {
      if (IS_MOBILE) resetJoystick();
      else {
        game.pointer.active = false;
        game.pointer.strength = 0;
      }
      handleBoostRelease();
    });

    window.addEventListener("touchend", e => {
      if (IS_MOBILE) return;
      game.pointer.active = false;
      game.pointer.strength = 0;
      handleBoostRelease();
    });

    startBtn.addEventListener("click", () => {
      startGame();
    });

    setBoostButtonState(false);
    drawBackground();
    requestAnimationFrame(loop);
  </script>
  <div id="footerBanner">제주대학교 58대 DREAM 총학생회 선거운동본부</div>
</body>
</html>
