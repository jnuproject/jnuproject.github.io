<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Slither Campus</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at 50% 25%, #1f2a3a 0%, #0b1119 65%);
      overflow: hidden;
      font-family: "Pretendard", "Segoe UI", Arial, sans-serif;
      color: #f1f5f9;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }
    #overlay {
      position: fixed;
      top: 18px;
      left: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 5;
      pointer-events: none;
    }
    #scoreBoard {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    #score {
      font-size: clamp(18px, 3vw, 28px);
      font-weight: 600;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
    }
    #remaining {
      font-size: clamp(14px, 2.4vw, 22px);
      font-weight: 500;
      color: #e2e8f0;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
    #modal {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, rgba(11, 15, 23, 0.92), rgba(4, 6, 10, 0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #modalContent {
      width: min(420px, 88vw);
      padding: clamp(26px, 6vw, 40px);
      border-radius: 20px;
      background: rgba(15, 25, 38, 0.9);
      box-shadow: 0 30px 80px rgba(3, 7, 18, 0.6);
      text-align: center;
    }
    #modalContent h1 {
      margin: 0 0 12px;
      font-size: clamp(26px, 7vw, 40px);
      letter-spacing: 0.8px;
    }
    #modalContent p {
      margin: 0 0 18px;
      line-height: 1.6;
      font-size: clamp(15px, 4vw, 17px);
      color: #cbd5f5;
    }
    #modalContent ul {
      list-style: none;
      padding: 0;
      margin: 0 0 22px;
      text-align: left;
      color: #94a3b8;
      font-size: clamp(13px, 3.6vw, 15px);
      display: grid;
      gap: 6px;
    }
    #startBtn {
      pointer-events: auto;
      cursor: pointer;
      border: none;
      border-radius: 999px;
      padding: 14px 36px;
      font-weight: 700;
      font-size: clamp(17px, 4.5vw, 20px);
      color: #0f172a;
      background: linear-gradient(120deg, #38bdf8 0%, #22d3ee 48%, #8b5cf6 100%);
      box-shadow: 0 18px 45px rgba(56, 189, 248, 0.45);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    #startBtn:active {
      transform: translateY(2px);
      box-shadow: 0 12px 28px rgba(56, 189, 248, 0.3);
    }
    @media (max-width: 640px) {
      #overlay {
        top: 12px;
        left: 12px;
      }
    }

    #mobileControls {
      position: fixed;
      bottom: 28px;
      left: 24px;
      right: 24px;
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 8;
      pointer-events: none;
    }
    body.mobile #mobileControls {
      display: flex;
    }
    #joystick {
      position: relative;
      width: clamp(150px, 36vw, 180px);
      height: clamp(150px, 36vw, 180px);
      pointer-events: auto;
      touch-action: none;
    }
    #joystickBase {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(59, 130, 246, 0.28) 0%, rgba(15, 23, 42, 0.65) 65%);
      border: 3px solid rgba(148, 163, 184, 0.45);
      box-shadow: 0 0 18px rgba(56, 189, 248, 0.45);
    }
    #joystickHandle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: clamp(70px, 18vw, 90px);
      height: clamp(70px, 18vw, 90px);
      border-radius: 50%;
      background: radial-gradient(circle, rgba(96, 165, 250, 0.9) 0%, rgba(37, 99, 235, 0.85) 85%);
      box-shadow: 0 0 14px rgba(37, 99, 235, 0.65);
      transform: translate(-50%, -50%);
      transition: transform 120ms ease-out;
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div id="overlay">
    <div id="scoreBoard">
      <div id="score">길이: 10</div>
      <div id="remaining">남은 난관: 99</div>
    </div>
  </div>
  <div id="mobileControls" aria-hidden="true">
    <div id="joystick">
      <div id="joystickBase"></div>
      <div id="joystickHandle"></div>
    </div>
  </div>
  <div id="modal" role="dialog" aria-modal="true">
    <div id="modalContent">
      <h1>캠퍼스 서바이벌</h1>
      <p>F학점 경고, 과제 폭탄, 팀플 잠수조 같은 캠퍼스 난관이 99마리의 지렁이로 몰려옵니다. 먹이를 먹어 성장하며 마지막까지 버텨보세요.</p>
      <ul>
        <li>• 모바일은 왼쪽 조이스틱으로, 데스크톱은 마우스/터치로 방향을 조절하세요.</li>
        <li>• 지렁이는 자동으로 가속합니다. 방향만 부드럽게 유지하고 충돌을 피하세요.</li>
        <li>• 난관(적)에게 머리가 닿으면 탈락합니다. 마지막 1인이 되면 승리!</li>
      </ul>
      <button id="startBtn">게임 시작</button>
    </div>
  </div>

  <script>
    const DPR = window.devicePixelRatio || 1;
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    const scoreDOM = document.getElementById("score");
    const remainingDOM = document.getElementById("remaining");
    const modalDOM = document.getElementById("modal");
    const startBtn = document.getElementById("startBtn");

    const WORLD_SIZE = 9000;
    const SAFE_RADIUS = 520;
    const INVULNERABLE_FRAMES = 160;
    const FOOD_TARGET = Math.floor((WORLD_SIZE * WORLD_SIZE) / 18000);
    const FOOD_SOFT_CAP = Math.floor(FOOD_TARGET * 1.35);
    const FOOD_HARD_CAP = Math.floor(FOOD_TARGET * 1.55);
    const CAMERA_BASE_ZOOM = 1;
    const CAMERA_MIN_ZOOM = 0.55;
    const CAMERA_BASE_ZOOM_MOBILE = 0.95;
    const CAMERA_MIN_ZOOM_MOBILE = 0.38;
    const TOTAL_SNAKES = 100;
    const IS_MOBILE = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent) || window.innerWidth < 768;
    const PLAYER_SIZE_SCALE = IS_MOBILE ? 0.75 : 1;
    const PLAYER_INITIAL_GROW = IS_MOBILE ? 28 : 40;
    if (remainingDOM) {
      remainingDOM.textContent = `남은 난관: ${TOTAL_SNAKES - 1}`;
    }

    const palette = [
      "#38bdf8", "#f472b6", "#fbbf24", "#4ade80", "#c084fc",
      "#f87171", "#f97316", "#22d3ee", "#34d399", "#a855f7",
    ];

    const threatThemes = [
      { base: "F학점", variants: ["위기", "경고", "재시험", "경보"], color: "#ef4444" },
      { base: "과제", variants: ["폭탄", "연쇄", "도배", "마감"], color: "#f97316" },
      { base: "팀플", variants: ["잠수조", "갈등", "대첩", "와해"], color: "#fb923c" },
      { base: "중간고사", variants: ["지뢰", "돌발", "회전문", "사격"], color: "#f87171" },
      { base: "기말고사", variants: ["태풍", "후폭풍", "카운트다운", "폭풍"], color: "#f43f5e" },
      { base: "출석", variants: ["체크", "경고", "패널티", "한도"], color: "#38bdf8" },
      { base: "등록금", variants: ["고지서", "폭등", "납부일", "압박"], color: "#14b8a6" },
      { base: "장학금", variants: ["컷라인", "위기", "경쟁", "과락"], color: "#8b5cf6" },
      { base: "수강신청", variants: ["대란", "전쟁", "난투", "폭주"], color: "#ec4899" },
      { base: "교수님", variants: ["추가과제", "깜짝퀴즈", "리포트", "회의록"], color: "#60a5fa" },
      { base: "취업", variants: ["자소서", "면접폭풍", "서류탈락", "코딩테스트"], color: "#0ea5e9" },
      { base: "졸업필수", variants: ["서류", "요건", "체크", "인증"], color: "#c084fc" },
    ];

    const threatSpecials = [
      { name: "마감 3시간", color: "#f97316" },
      { name: "노션 200알림", color: "#fb7185" },
      { name: "팀플 단톡 58", color: "#38bdf8" },
      { name: "새벽 카톡 공지", color: "#60a5fa" },
      { name: "등록금 고지서", color: "#14b8a6" },
      { name: "F학점 경고장", color: "#ef4444" },
      { name: "기말 대비 스터디", color: "#a855f7" },
      { name: "과제 3연속 알림", color: "#f59e0b" },
    ];

    const joystickElement = document.getElementById("joystick");
    const joystickBase = document.getElementById("joystickBase");
    const joystickHandle = document.getElementById("joystickHandle");

    if (IS_MOBILE) {
      document.body.classList.add("mobile");
    } else {
      document.body.classList.remove("mobile");
    }

    const joystickState = {
      active: false,
      identifier: null,
      vector: { x: 0, y: 0 },
    };

    const game = {
      snakes: [],
      foods: [],
      player: null,
      pointer: { x: 0, y: 0, active: false },
      running: false,
      lastTs: performance.now(),
      camera: { x: 0, y: 0, zoom: IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM },
    };

    function centerJoystickHandle() {
      if (!joystickHandle) return;
      joystickHandle.style.transform = "translate(-50%, -50%)";
    }

    function applyJoystickInput(nx, ny) {
      joystickState.vector.x = nx;
      joystickState.vector.y = ny;
      const magnitude = Math.min(1, Math.hypot(nx, ny));
      if (magnitude < 0.06) {
        game.pointer.active = false;
        return;
      }
      const pointerRadius = Math.min(canvas.width / DPR, canvas.height / DPR) * (IS_MOBILE ? 0.5 : 0.45);
      const centerX = canvas.width / (2 * DPR);
      const centerY = canvas.height / (2 * DPR);
      setPointerPosition(centerX + nx * pointerRadius, centerY + ny * pointerRadius);
    }

    function resetJoystick() {
      if (!IS_MOBILE) return;
      joystickState.active = false;
      joystickState.identifier = null;
      joystickState.vector.x = 0;
      joystickState.vector.y = 0;
      centerJoystickHandle();
      game.pointer.active = false;
      game.pointer.x = canvas.width / (2 * DPR);
      game.pointer.y = canvas.height / (2 * DPR);
    }

    function updateJoystickFromTouch(touch) {
      if (!joystickBase || !joystickHandle) return;
      const rect = joystickBase.getBoundingClientRect();
      const baseRadius = rect.width / 2;
      const dx = touch.clientX - (rect.left + baseRadius);
      const dy = touch.clientY - (rect.top + baseRadius);
      let nx = dx / Math.max(baseRadius, 1);
      let ny = dy / Math.max(baseRadius, 1);
      const length = Math.hypot(nx, ny);
      if (length > 1) {
        nx /= length;
        ny /= length;
      }
      const handleTravel = baseRadius * 0.6;
      joystickHandle.style.transform = `translate(-50%, -50%) translate(${nx * handleTravel}px, ${ny * handleTravel}px)`;
      applyJoystickInput(nx, ny);
    }

    function onJoystickStart(e) {
      if (!IS_MOBILE || joystickState.active) return;
      const touch = e.changedTouches && e.changedTouches[0];
      if (!touch) return;
      joystickState.active = true;
      joystickState.identifier = touch.identifier;
      updateJoystickFromTouch(touch);
      e.preventDefault();
    }

    function onJoystickMove(e) {
      if (!IS_MOBILE || !joystickState.active) return;
      const touch = Array.from(e.changedTouches || []).find(t => t.identifier === joystickState.identifier);
      if (!touch) return;
      updateJoystickFromTouch(touch);
      e.preventDefault();
    }

    function onJoystickEnd(e) {
      if (!IS_MOBILE || !joystickState.active) return;
      const touch = Array.from(e.changedTouches || []).find(t => t.identifier === joystickState.identifier);
      if (!touch) return;
      resetJoystick();
      e.preventDefault();
    }

    function resize() {
      canvas.width = window.innerWidth * DPR;
      canvas.height = window.innerHeight * DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      if (IS_MOBILE && !joystickState.active) {
        centerJoystickHandle();
      }
    }
    resize();
    window.addEventListener("resize", resize);

    if (IS_MOBILE) {
      centerJoystickHandle();
      if (joystickElement) {
        joystickElement.addEventListener("touchstart", onJoystickStart, { passive: false });
        joystickElement.addEventListener("touchmove", onJoystickMove, { passive: false });
        joystickElement.addEventListener("touchend", onJoystickEnd, { passive: false });
        joystickElement.addEventListener("touchcancel", onJoystickEnd, { passive: false });
      }
    }

    function randRange(range) {
      return (Math.random() * 2 - 1) * range;
    }

    function randFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function generateThreat() {
      if (Math.random() < 0.35 && threatSpecials.length) {
        const special = randFrom(threatSpecials);
        return { name: special.name, color: special.color };
      }
      const theme = randFrom(threatThemes);
      const variant = randFrom(theme.variants);
      return { name: `${theme.base} ${variant}`, color: theme.color };
    }

    function safeSpawn(minDistance = SAFE_RADIUS, maxAttempts = 30) {
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const pos = {
          x: randRange(WORLD_SIZE * 0.45),
          y: randRange(WORLD_SIZE * 0.45),
        };
        let ok = true;
        for (const snake of game.snakes) {
          const dx = pos.x - snake.head.x;
          const dy = pos.y - snake.head.y;
          if (Math.hypot(dx, dy) < minDistance + snake.radius * 1.5) {
            ok = false;
            break;
          }
        }
        if (ok) return pos;
      }
      return {
        x: randRange(WORLD_SIZE * 0.45),
        y: randRange(WORLD_SIZE * 0.45),
      };
    }

    function isGameActive() {
      return game.running && game.player && game.player.alive;
    }

    function canPlayerScore() {
      return game.player && game.player.alive && game.running;
    }

    function setPointerPosition(x, y) {
      game.pointer.x = x;
      game.pointer.y = y;
      game.pointer.active = true;
    }

    class Food {
      constructor(x, y, value = 4) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = 4 + value * 0.8;
        this.color = randFrom(palette);
      }
      draw(camera) {
        const width = canvas.width / DPR;
        const height = canvas.height / DPR;
        const zoom = camera.zoom;
        const { x: sx, y: sy } = worldToScreen(this.x, this.y);
        if (sx < -50 || sx > width + 50 || sy < -50 || sy > height + 50) return;

        const radius = this.radius * zoom;
        const gradient = ctx.createRadialGradient(sx, sy, radius * 0.2, sx, sy, radius);
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(1, this.color);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Snake {
      constructor(opts) {
        this.isPlayer = opts.isPlayer;
        this.name = opts.name;
        this.color = opts.color;
        this.sizeScale = opts.sizeScale ?? 1;
        this.baseLength = Math.max(40, Math.round(80 * this.sizeScale));
        this.baseRadius = 16 * this.sizeScale;
        this.baseSpacing = 6 * this.sizeScale;
        this.segments = [];
        this.radius = this.baseRadius;
        this.length = this.baseLength;
        this.spacing = this.baseSpacing;
        this.speed = 2.4;
        this.turnRate = 0.08;
        this.direction = Math.random() * Math.PI * 2;
        this.alive = true;
        this.score = 10;
        this.invulnerable = INVULNERABLE_FRAMES;
        this.target = null;
        this.maxSpeed = this.isPlayer ? 2.7 : 2.2 + Math.random() * 0.6;
        this.spawn(opts.x, opts.y);
      }

      spawn(x, y) {
        this.segments = [];
        const angle = this.direction;
        for (let i = 0; i < this.length; i++) {
          this.segments.push({
            x: x - Math.cos(angle) * i * this.spacing,
            y: y - Math.sin(angle) * i * this.spacing,
          });
        }
      }

      get head() {
        return this.segments[0];
      }

      grow(amount) {
        if (!Number.isFinite(amount) || amount <= 0) return;
        if (this.isPlayer && !canPlayerScore()) {
          return;
        }
        this.score += amount * 0.6;
        if (!Number.isFinite(this.score)) {
          this.score = 10;
        }
        this.length += amount;
        const tail = this.segments[this.segments.length - 1];
        for (let i = 0; i < amount; i++) {
          this.segments.push({ x: tail.x, y: tail.y });
        }
        const baseRadius = 12 + Math.min(26, this.segments.length / 14);
        this.radius = baseRadius * this.sizeScale;
        const baseSpacing = 6 + Math.min(2, baseRadius / 12);
        this.spacing = baseSpacing * this.sizeScale;
      }

      updatePointer(delta) {
        if (!this.isPlayer) return;
        if (!game.running || !this.alive || !game.pointer.active) return;
        if (!isGameActive()) return;
        const { x, y } = screenToWorld(game.pointer.x, game.pointer.y);
        const dx = x - this.head.x;
        const dy = y - this.head.y;
        const targetAngle = Math.atan2(dy, dx);

        let diff = targetAngle - this.direction;
        diff = Math.atan2(Math.sin(diff), Math.cos(diff));
        this.direction += diff * Math.min(1, this.turnRate * delta * 3.2);
        this.speed = Math.min(this.maxSpeed, this.speed + 0.02 * delta);
      }

      chooseTarget() {
        if (this.isPlayer) return;
        if (this.target && this.target.x != null && this.target.y != null && Math.random() > 0.01) return;

        if (Math.random() < 0.6 && game.foods.length) {
          const food = randFrom(game.foods);
          if (food) {
            this.target = { x: food.x, y: food.y, wander: false };
            return;
          }
        }
        this.target = {
          x: this.head.x + randRange(500),
          y: this.head.y + randRange(500),
          wander: true,
        };
      }

      steerAI(delta) {
        if (this.isPlayer || !this.target) return;
        if (typeof this.target.x !== "number" || typeof this.target.y !== "number") {
          this.target = null;
          return;
        }
        const dx = this.target.x - this.head.x;
        const dy = this.target.y - this.head.y;
        const targetAngle = Math.atan2(dy, dx);
        let diff = targetAngle - this.direction;
        diff = Math.atan2(Math.sin(diff), Math.cos(diff));
        const modifier = this.target.wander ? 0.35 : 1;
        this.direction += diff * Math.min(1, this.turnRate * delta * modifier);
        if (!this.target.wander && Math.hypot(dx, dy) < 24) {
          this.target = null;
        }
        if (this.target && this.target.wander && Math.random() < 0.015) {
          this.target = null;
        }
      }

      moveForward(delta) {
        const distance = this.speed * delta * 1.18;
        const newX = this.head.x + Math.cos(this.direction) * distance;
        const newY = this.head.y + Math.sin(this.direction) * distance;

        this.segments.unshift({ x: newX, y: newY });
        while (this.segments.length > this.length) {
          this.segments.pop();
        }

        for (let i = 1; i < this.segments.length; i++) {
          const prev = this.segments[i - 1];
          const seg = this.segments[i];
          const dx = seg.x - prev.x;
          const dy = seg.y - prev.y;
          const dist = Math.hypot(dx, dy);
          if (dist > this.spacing) {
            const ratio = this.spacing / dist;
            seg.x = prev.x + dx * ratio;
            seg.y = prev.y + dy * ratio;
          }
        }
      }

      keepInside() {
        const bound = WORLD_SIZE / 2 - 200;
        let bounced = false;

        if (this.head.x < -bound) {
          this.head.x = -bound;
          bounced = true;
        } else if (this.head.x > bound) {
          this.head.x = bound;
          bounced = true;
        }
        if (this.head.y < -bound) {
          this.head.y = -bound;
          bounced = true;
        } else if (this.head.y > bound) {
          this.head.y = bound;
          bounced = true;
        }

        if (bounced) {
          this.direction = Math.atan2(-Math.sin(this.direction), -Math.cos(this.direction));
          for (let i = 1; i < this.segments.length; i++) {
            const prev = this.segments[i - 1];
            const seg = this.segments[i];
            const dx = seg.x - prev.x;
            const dy = seg.y - prev.y;
            const dist = Math.hypot(dx, dy) || 0.0001;
            const ratio = this.spacing / dist;
            seg.x = prev.x - dx * ratio;
            seg.y = prev.y - dy * ratio;
          }
        }
      }

      update(delta) {
        if (!this.alive) return;
        if (this.invulnerable > 0) {
          this.invulnerable = Math.max(0, this.invulnerable - delta);
        }
        this.updatePointer(delta);
        this.chooseTarget();
        this.steerAI(delta);
        this.moveForward(delta);
        this.keepInside();
        const baseRadius = 12 + Math.min(28, this.segments.length / 12);
        this.radius = baseRadius * this.sizeScale;
      }

      draw(camera) {
        if (!this.alive) return;
        const zoom = camera.zoom;
        const headScreen = worldToScreen(this.head.x, this.head.y);
        const gradient = ctx.createLinearGradient(
          headScreen.x,
          headScreen.y,
          headScreen.x + Math.cos(this.direction) * 40 * zoom,
          headScreen.y + Math.sin(this.direction) * 40 * zoom
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.7, "#ffffff22");
        gradient.addColorStop(1, "#ffffff55");

        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.radius * 1.15 * zoom;
        ctx.beginPath();
        for (let i = 0; i < this.segments.length; i++) {
          const seg = this.segments[i];
          const screen = worldToScreen(seg.x, seg.y);
          if (i === 0) ctx.moveTo(screen.x, screen.y);
          else ctx.lineTo(screen.x, screen.y);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = "#ffffff12";
        ctx.lineWidth = Math.max(5 * zoom, this.radius * 0.4 * zoom);
        for (let i = 3; i < this.segments.length; i += 5) {
          const seg = this.segments[i];
          const screen = worldToScreen(seg.x, seg.y);
          ctx.moveTo(screen.x, screen.y);
          ctx.lineTo(screen.x, screen.y);
        }
        ctx.stroke();

        const headX = headScreen.x;
        const headY = headScreen.y;

        ctx.save();
        ctx.translate(headX, headY);
        ctx.rotate(this.direction);

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radius * 0.9 * zoom, this.radius * 0.72 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(this.radius * 0.35 * zoom, -this.radius * 0.25 * zoom, this.radius * 0.2 * zoom, 0, Math.PI * 2);
        ctx.arc(this.radius * 0.35 * zoom, this.radius * 0.25 * zoom, this.radius * 0.2 * zoom, 0, Math.PI * 2);
        ctx.fill();

        if (this.invulnerable <= 0) {
          ctx.strokeStyle = "#f43f5e";
          ctx.lineWidth = Math.max(2 * zoom, this.radius * 0.16 * zoom);
          ctx.beginPath();
          ctx.moveTo(this.radius * 0.7 * zoom, 0);
          ctx.lineTo(
            this.radius * 1.2 * zoom,
            Math.sin(performance.now() * 0.012) * this.radius * 0.3 * zoom
          );
          ctx.stroke();
        }

        ctx.restore();

        if (this.invulnerable > 0) {
          ctx.strokeStyle = "rgba(96, 165, 250, 0.45)";
          ctx.lineWidth = this.radius * 0.35 * zoom;
          ctx.beginPath();
          ctx.arc(headX, headY, this.radius * 1.25 * zoom, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillStyle = this.isPlayer ? "#facc15" : "#e2e8f0";
        const baseFont = this.isPlayer ? 16 : 14;
        const fontSize = Math.max(12, baseFont * zoom);
        ctx.font = `${fontSize}px "Segoe UI"`;
        ctx.fillText(
          this.isPlayer ? `나 (${Math.floor(this.score)})` : `${this.name}`,
          headX + 22 * zoom,
          headY - this.radius * zoom - 8 * zoom
        );
      }
    }

    function screenToWorld(sx, sy) {
      const zoom = game.camera.zoom || 1;
      return {
        x: sx / zoom + game.camera.x,
        y: sy / zoom + game.camera.y,
      };
    }

    function worldToScreen(wx, wy) {
      const zoom = game.camera.zoom || 1;
      return {
        x: (wx - game.camera.x) * zoom,
        y: (wy - game.camera.y) * zoom,
      };
    }

    function populateFoods() {
      game.foods.length = 0;
      for (let i = 0; i < FOOD_TARGET; i++) {
        const pos = safeSpawn(0, 1);
        game.foods.push(new Food(pos.x, pos.y, Math.random() * 4 + 2));
      }
    }

    function spawnAI(count) {
      const amount = Math.max(0, Math.floor(count));
      for (let i = 0; i < amount; i++) {
        const pos = safeSpawn();
        const threat = generateThreat();
        const color = threat.color || randFrom(palette);
        const bot = new Snake({
          x: pos.x,
          y: pos.y,
          color,
          name: threat.name,
          isPlayer: false,
          sizeScale: 1,
        });
        bot.grow(Math.floor(Math.random() * 120) + 40);
        game.snakes.push(bot);
      }
    }

    function dropFoodFromSnake(snake) {
      const dropInterval = Math.max(4, Math.floor(snake.segments.length / 22));
      for (let i = 0; i < snake.segments.length; i += dropInterval) {
        const seg = snake.segments[i];
        const count = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < count; j++) {
          const offsetX = (Math.random() - 0.5) * snake.radius * 1.6;
          const offsetY = (Math.random() - 0.5) * snake.radius * 1.6;
          game.foods.push(new Food(seg.x + offsetX, seg.y + offsetY, 4 + Math.random() * 4));
        }
      }
    }

    function trimOldFoods(limit) {
      const excess = game.foods.length - limit;
      if (excess > 0) {
        game.foods.splice(0, excess);
      }
    }

    function enforceFoodCap() {
      if (game.foods.length <= FOOD_SOFT_CAP) return;
      if (game.foods.length > FOOD_HARD_CAP) {
        trimOldFoods(FOOD_HARD_CAP);
      }
      const trimmedTo = Math.floor(FOOD_TARGET * 1.1);
      const targetLength = Math.min(trimmedTo, FOOD_SOFT_CAP, FOOD_HARD_CAP);
      if (game.foods.length > targetLength) {
        trimOldFoods(targetLength);
      }
    }

    function killSnake(snake) {
      if (!snake.alive) return;
      snake.alive = false;
      dropFoodFromSnake(snake);
      updateRemaining();

      if (snake.isPlayer) {
        game.running = false;
        game.pointer.active = false;
        scoreDOM.textContent = `길이: ${Math.floor(snake.score)}`;
        modalDOM.querySelector("h1").textContent = "게임 오버";
        modalDOM.querySelector("p").innerHTML = `최종 길이: ${Math.floor(snake.score)}<br/>다시 한 번 도전해 볼까요?`;
        startBtn.textContent = "다시 시작";
        modalDOM.style.display = "flex";
        if (IS_MOBILE) resetJoystick();
      }
      checkForVictory();
    }

    function handleVictory() {
      if (!game.player) return;
      game.running = false;
      game.pointer.active = false;
      updateScore();
      updateRemaining();
      modalDOM.querySelector("h1").textContent = "최후의 1인!";
      modalDOM.querySelector("p").innerHTML = `축하합니다! 모든 캠퍼스 난관을 정복했습니다.<br/>최종 길이: ${Math.floor(game.player.score)}`;
      startBtn.textContent = "다시 시작";
      modalDOM.style.display = "flex";
      if (IS_MOBILE) resetJoystick();
    }

    function checkForVictory() {
      if (!game.player || !game.player.alive) return;
      let aliveCount = 0;
      for (const snake of game.snakes) {
        if (snake.alive) aliveCount += 1;
      }
      if (aliveCount === 1) {
        handleVictory();
      }
    }

    function collectFood(snake) {
      const head = snake.head;
      if (!head) return;
      for (let i = game.foods.length - 1; i >= 0; i--) {
        const food = game.foods[i];
        if (!food) continue;
        const dx = food.x - head.x;
        const dy = food.y - head.y;
        const maxRange = snake.radius + food.radius * 0.75;
        if (Math.abs(dx) > maxRange || Math.abs(dy) > maxRange) continue;
        if (dx * dx + dy * dy < maxRange * maxRange) {
          snake.grow(Math.ceil(food.value));
          game.foods.splice(i, 1);
        }
      }
      if (game.foods.length < FOOD_TARGET) {
        const pos = safeSpawn(0, 1);
        game.foods.push(new Food(pos.x, pos.y, 3 + Math.random() * 4));
      }
    }

    function detectCollisions() {
      const snakes = game.snakes.filter(s => s.alive);
      for (const snake of snakes) {
        collectFood(snake);
        for (const other of snakes) {
          if (snake === other || !other.alive) continue;
          if (snake.invulnerable > 0 || other.invulnerable > 0) continue;
          for (let i = 8; i < other.segments.length; i++) {
            const seg = other.segments[i];
            const dx = seg.x - snake.head.x;
            const dy = seg.y - snake.head.y;
            if (Math.hypot(dx, dy) < snake.radius * 0.75) {
              if (snake.isPlayer) {
                killSnake(snake);
                return;
              } else {
                killSnake(snake);
                break;
              }
            }
          }
        }
      }
    }

    function updateScore() {
      if (!game.player || !game.player.alive) return;
      scoreDOM.textContent = `길이: ${Math.floor(game.player.score)}`;
    }

    function updateRemaining() {
      if (!remainingDOM) return;
      let aliveCount = 0;
      for (const snake of game.snakes) {
        if (snake.alive) aliveCount += 1;
      }
      const playerAlive = game.player && game.player.alive ? 1 : 0;
      const threatsLeft = Math.max(0, aliveCount - playerAlive);
      remainingDOM.textContent = `남은 난관: ${threatsLeft}`;
    }

    function updateCamera() {
      if (!game.player) return;
      const width = canvas.width / DPR;
      const height = canvas.height / DPR;
      const player = game.player;

      const baseZoom = IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM;
      const minZoom = IS_MOBILE ? CAMERA_MIN_ZOOM_MOBILE : CAMERA_MIN_ZOOM;
      const growth = Math.max(0, player.segments.length - player.baseLength);
      const growthDivisor = IS_MOBILE ? 120 : 220;
      const maxProgress = IS_MOBILE ? 1.4 : 1;
      const sizeProgress = clamp(growth / growthDivisor, 0, maxProgress);
      const desiredZoom = baseZoom - sizeProgress * (baseZoom - minZoom);
      const smoothing = IS_MOBILE ? 0.08 : 0.06;
      game.camera.zoom += (desiredZoom - game.camera.zoom) * smoothing;
      game.camera.zoom = clamp(game.camera.zoom, minZoom, baseZoom);

      const halfWidth = (width / game.camera.zoom) * 0.5;
      const halfHeight = (height / game.camera.zoom) * 0.5;
      const desiredX = player.head.x - halfWidth;
      const desiredY = player.head.y - halfHeight;

      const minX = -WORLD_SIZE / 2;
      const maxX = Math.max(minX, WORLD_SIZE / 2 - width / game.camera.zoom);
      const minY = -WORLD_SIZE / 2;
      const maxY = Math.max(minY, WORLD_SIZE / 2 - height / game.camera.zoom);

      const clampedX = clamp(desiredX, minX, maxX);
      const clampedY = clamp(desiredY, minY, maxY);

      game.camera.x += (clampedX - game.camera.x) * 0.12;
      game.camera.y += (clampedY - game.camera.y) * 0.12;
    }

    function drawBackground() {
      const tile = 160;
      const width = canvas.width / DPR;
      const height = canvas.height / DPR;
      const zoom = game.camera.zoom;
      const left = game.camera.x;
      const top = game.camera.y;
      const right = left + width / zoom;
      const bottom = top + height / zoom;
      const startX = Math.floor(left / tile) * tile;
      const startY = Math.floor(top / tile) * tile;

      ctx.fillStyle = "rgba(10, 15, 23, 0.75)";
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = "rgba(56, 68, 90, 0.18)";
      ctx.lineWidth = 1;
      for (let x = startX; x <= right; x += tile) {
        const screenX = (x - left) * zoom;
        ctx.beginPath();
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, height);
        ctx.stroke();
      }
      for (let y = startY; y <= bottom; y += tile) {
        const screenY = (y - top) * zoom;
        ctx.beginPath();
        ctx.moveTo(0, screenY);
        ctx.lineTo(width, screenY);
        ctx.stroke();
      }

      ctx.strokeStyle = "rgba(148, 163, 184, 0.12)";
      ctx.lineWidth = 4;
      const bounds = WORLD_SIZE / 2;
      const rectX = (-bounds - left) * zoom;
      const rectY = (-bounds - top) * zoom;
      ctx.strokeRect(rectX, rectY, WORLD_SIZE * zoom, WORLD_SIZE * zoom);
    }

    function update(delta) {
      for (const snake of game.snakes) snake.update(delta);
      detectCollisions();
      updateCamera();
      updateScore();
      updateRemaining();
      if (game.foods.length > FOOD_SOFT_CAP) enforceFoodCap();
    }

    function draw() {
      drawBackground();
      for (const food of game.foods) food.draw(game.camera);
      for (const snake of game.snakes) snake.draw(game.camera);
    }

    function loop(ts) {
      const delta = Math.min(6, (ts - game.lastTs) / (1000 / 60));
      game.lastTs = ts;
      if (game.running && game.player) {
        update(delta);
        draw();
      } else {
        drawBackground();
        game.foods.forEach(food => food.draw(game.camera));
        game.snakes.forEach(snake => snake.draw(game.camera));
      }
      requestAnimationFrame(loop);
    }

    function startGame() {
      modalDOM.querySelector("h1").textContent = "캠퍼스 서바이벌";
      modalDOM.querySelector("p").innerHTML = `F학점 경고, 과제 폭탄, 팀플 잠수조 같은 캠퍼스 난관 99마리를 뚫고 마지막 생존자가 되어보세요.`;
      startBtn.textContent = "게임 시작";
      game.snakes.length = 0;
      game.foods.length = 0;
      game.camera.x = 0;
      game.camera.y = 0;
      game.camera.zoom = IS_MOBILE ? CAMERA_BASE_ZOOM_MOBILE : CAMERA_BASE_ZOOM;
      game.pointer.active = false;
      populateFoods();

      const player = new Snake({
        x: 0,
        y: 0,
        color: "#38bdf8",
        name: "You",
        isPlayer: true,
        sizeScale: PLAYER_SIZE_SCALE,
      });
      player.grow(PLAYER_INITIAL_GROW);
      game.player = player;
      game.snakes.push(player);
      spawnAI(TOTAL_SNAKES - 1);
      updateRemaining();
      updateScore();

      game.running = true;
      game.lastTs = performance.now();
      modalDOM.style.display = "none";
      setPointerPosition(canvas.width / (2 * DPR), canvas.height / (2 * DPR));
      if (IS_MOBILE) {
        resetJoystick();
      }
    }

    canvas.addEventListener("mousemove", e => {
      if (!isGameActive()) return;
      setPointerPosition(e.clientX, e.clientY);
    });

    canvas.addEventListener("mouseleave", () => {
      game.pointer.active = false;
    });

    if (!IS_MOBILE) {
      canvas.addEventListener("touchstart", e => {
        if (!isGameActive()) return;
        const touch = e.touches[0];
        setPointerPosition(touch.clientX, touch.clientY);
      }, { passive: false });

      canvas.addEventListener("touchmove", e => {
        if (!isGameActive()) return;
        const touch = e.touches[0];
        setPointerPosition(touch.clientX, touch.clientY);
      }, { passive: false });

      canvas.addEventListener("touchend", () => {
        game.pointer.active = false;
      });
    }

    window.addEventListener("blur", () => {
      if (IS_MOBILE) resetJoystick();
      else game.pointer.active = false;
    });

    window.addEventListener("touchend", e => {
      if (IS_MOBILE) return;
      game.pointer.active = false;
    });

    startBtn.addEventListener("click", () => {
      startGame();
    });

    drawBackground();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
